
ttd november, go through these notes as soon as you've got passwords as a user credential

/*
draft password design:

hash on the client; make the attacker spend the processor cycles
require 6 characters, encourage upper/lower/number/symbol with green checks, but don't require
if hashing takes 10ms you calculated it would take 18 years to guess all the 6 character upper/lower/number
and you'll probabl use 100,000 cycles, which may take 100ms

there's one factory preset seed, called seed1, hard coded in the client component
this means that an attacker would have to make a new rainbow table
and if that becomes a problem, switch to one seed per set password by adding that to the database

this darkpenny approach is in addition to the site-wide rate limiter
which protects separate and addition to this system
which is also strong alone!

most users won't authenticate with passwords at all, also

standard practice is to hash on the server side, because client code isn't trusted
but on the server we'll pay for the attacker's computational work, not make them do so!
also, imagine the server is compromised, or somehow, the connection is snooped
hashing on the client, the user's password never leaves the client
*/







/*
this example is all on the client
as the user types show checks for upper/lower/digit/special
too short, and password not the same (to set, two boxes, that pattern)

and then on submit, show the hash, and say how long 10, 50, 100, 250k iterations took
and then try that on current and old phones and laptops
chat's guess is that 100k is 100ms, which is fine

oh, you have that really crappy android tablet, try it there, too


*/



/*
no form tag below
button works, but enter doesn't press button
what are different ways to make enter also work? or is the best way the form tag

oh, also, you need to do the eyelid control
it'll be interesting to see what that is, and how you get it inside the text box

*/

/*
instead of failing or warning on caps lock on, why not try it boht ways?
*/



/*
note about how, to begin, these are public constants
and that's very strong and totall fine
but in the future, it won't be hard to change to more iterations
or even a separate salt for each password set
*/
/*
let's say the attacker knows a user's password is 6 letters and numbers
and he's got fast computers, which can do 100k loops for a password in 10ms
how much processor time will it take him to crack it?

26 + 26 + 10 = 62 possible digits
62 ^ 6 = 56800235584 possible passwords
56800235584 * 10 = 568002355840 milliseconds compute time to hash them all
568002355840 / Time.year = 17.9989 years!
*/


/*
this is also where you should make a component that is your visible log box
like, make it reusable, and use it here and future places
currently you have a few bespoke versions scattered about
*/

/*
password page backlog
[x]enter shows hash and time
[x]try on devices fast and slow (XXms rtx, 160ms main box, 450ms cheap tablet)
[]hidden password with dots
[]eyelid control to show
[]strength-o-meter
[]second box to confirm
*/


/*
ttd april2025
evolution of thinking of how/if to use passwords in the system
1 code them normal
2 don't use them at all, they're compromised by both attackers and google/apple fighting to popups over each other to steal users' with the new Passkey web standards
3 include them, but only if the user digs to find them

along those lines, what to do about strength and requirements
as this is buried, ok to be unconventional:
- always show the password, not hidden, no show button
- hash on device, and for a long time, like ten seconds on a recent iphone
- no strength requirements or strength at all


*/


/*
ttd november2024 remember when comparing *even password hashes* on the server to use your fancy new secureSameText(s1, s2)
otherwise, the attacker won't bother computing hash values on his client at all, and will just guess forward the hash value--he'll never get the password, but will gain access to the account!
*/

/*
ttd november
crazy unnecessary optimization idea so that the number of iterations is chosen by the speed of the user's device where they set their password
to set a password, it does units of 100k iterations until the last one brings the total delay above a half second
ok and then how does that work? the server stores the iteration count with the password, i suppose, and tells the page this
yeah, that is pretty cool, because it scales forward as moore's law keeps mooring

*/






the variable strength idea
do units of 100k cycles
store number as exact cycles
do a first one with the timer off to warm up the processor
then measure the speed of the second
then choose how many you're going to do, oh actually you could hit math for exactly 420ms, yeah, do that




calculate the number of iterations in 420ms
also have a minimum of 420_000 iterations in case the user's device is really slow











test(async () => {

	//example given parameters
	let passwordText = 'hello'

	//example factory presets
	let saltData = Data({base32: '774GOUNJC2OSI3X76LCZLPTPZQ'})
	let minimumCycles = 420_000
	let targetTime = 420

	let cycles = await hashPasswordMeasureSpeed(saltData, passwordText, minimumCycles, targetTime)
	log(cycles)



})



test(async () => {

	//example given parameters
	let plain = 'hello'

	//factory presets
	let salt = '774GOUNJC2OSI3X76LCZLPTPZQ'
	let saltData = Data({base32: salt})
	let warmCycles = 1_000
	let testCycles = 420_000
	let targetTime = 420
	let minimumCycles = 420_000

	//start with a sha256 sum so cycle number can't be a clue as to plaintext password length
	let passwordHashText = await hashText(plain)

	//warm up PBKDF2 to keep a cold start time out of our stopwatch next
	await hashPassword(warmCycles, saltData, passwordHashText)

	let t = performance.now()//returns float for sub-millisecond accuracy
	await hashPassword(testCycles, saltData, passwordHashText)
	let testDuration = performance.now() - t
	if (testDuration == 0) d = 1//replace no time at all with 1ms; astonishingly fast computer but we can't divide by zero

	//at that speed, how many cycles do we need to use up a target time of 420 milliseconds?
	let cycles = Math.round(targetTime * testCycles / testDuration)
	if (cycles < minimumCycles) cycles = minimumCycles

	//and so at last, hash the password that number of cycles
	t = Now()
	let hash = (await hashPassword(cycles, saltData, passwordHashText)).base32()
	let duration = Now() - t

	log(look({plain, passwordHashText, testDuration, cycles, hash, duration}))


/*
	//moore's mixer
	//hash the password so speed can be a clue as to length
	let hash = await hashText(password)

	//warm up the device so our speed test doesn't include a cold start time
	await hashPassword(1_000, salt, hash)

	//stopwatch a small number of cycles to see how fast the page's processor is
	let t = performance.now()
	let h = await hashPassword(420_000, salt, hash)
	let d = performance.now() - t

	//from that speed, calculate how many cycles the page has to do to use up 420ms
	if (d == 0) d = 1//d 0 would mean incredibly fast computer; change to 1ms to avoid divide by zero
	let cycles = Math.floor(420 * 420_000 / d)

	//hash the hash that many cycles
	let t = Now()
	let h = await hashPassword(iterations, salt, password)
	let duration = Now() - t

	refOutput.value = `${h.base32()} hashed from ${iterations} thousand iterations in ${duration}ms on ${sayTick(t)}`


	log(password, hash, h.base32(), d, cycles)

	t = Now()
	h = await hashPassword(cycles, salt, hash)


*/



















})









async function onEnter() {
	if (!hasText(refInput.value)) refInput.value = 'hello'
	let password = refInput.value

	//moore's mixer
	//hash the password so speed can be a clue as to length
	let hash = await hashText(password)

	//warm up the device so our speed test doesn't include a cold start time
	await hashPassword(1_000, salt, hash)

	//stopwatch a small number of cycles to see how fast the page's processor is
	let t = performance.now()
	let h = await hashPassword(420_000, salt, hash)
	let d = performance.now() - t

	//from that speed, calculate how many cycles the page has to do to use up 420ms
	if (d == 0) d = 1//d 0 would mean incredibly fast computer; change to 1ms to avoid divide by zero
	let cycles = Math.floor(420 * 420_000 / d)

	//hash the hash that many cycles
	let t = Now()
	let h = await hashPassword(iterations, salt, password)
	let duration = Now() - t

	refOutput.value = `${h.base32()} hashed from ${iterations} thousand iterations in ${duration}ms on ${sayTick(t)}`


	log(password, hash, h.base32(), d, cycles)

	t = Now()
	h = await hashPassword(cycles, salt, hash)

		//ok, here i need to see how many cycles we can do in 420ms

	//measure how fast the page can

	/*
	d is duration count of milliseconds the page could do 420_000 cycles
	now we want to calculate how many cycles to require for a time of 420 milliseconds

	d milliseconds / 420_000 cycles
	420 milliseconds / x cycles


	*/

}

/*
ok, new idea
sha256sum the password once so they're all the same length, do base16
do a throwaway 1k cycles
measure the time for 100k cycles
measure how fast the page can hash that 
*/




























