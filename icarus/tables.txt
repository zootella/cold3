


demo
so far in the database

i've been coding for years, but am totally new to databases!
ive never written a schema before

no jwt - a format for a format, and expiration
no orm - instead just functions that look at grids of text and numbers

example_table and a demonstration of types
column title defines type for sanity checking

strategy
keep things simple and verbose in the database
keep things really simple in the browser
handfuls of quick queries in the worker bring it together

tables are ledgers; we append to them
instead of deleting a row, mark it as hidden




























don't build wide at this level at thi stime
rather, sketch out what you'll need for the next list of things, like:
attestation - this user has proven they control this address, different forms
governor - the system messaged this address hash this long ago, this many times
browser - this user tag is signed in with these browser tags
code - the we texted you this many numbers
and then the other functions which you may need in the future, list those here in a brief comment, but don't code them

how does sign-in work, separate 

how dose code work, separate 


database tables:
1 hold simple, atomic facts (rather than the results of logic examining those facts)
	example: one row for sent code, another row for entered code
2 are a ledger that grows, rather than changes
	example: one row for added email, another later timestamped row for removed email
3 hold different kinds of data in a column (rather than having different tables for data)
	example: one table for every way to sign in, that grows as we add new sign-in methods (rather than JOINs between tables about email, sms, x, metamask, etc.)

first, sketch out on paper what the user does and what the system does through valid flows

a user, already signed in, returns to the site

an attacker enters a victims email address many times to get the victim to be sent codes they don't need

a user signes up with email
and then validates that email address

a user, already signed in, 

an anonymous user sets their nickname, and stars something

a signed-in user authenticates with another factor to perform a protected action, like changing sign in
these permissions only extend to their current device
an hour later, their permission level on that device returns to normal

a new user gets codes to validate their email address adn then sms number
the second code they get is code B
the third code they get is 6 digits, not 4

a user signs in on desktop
then on mobile
returns later and is still signed in
then signs out of everywhere on desktop
(what table links a user tag to their browser tags?)
(when does a user get a user tag? how does this work with anonymous users following a feed and renaming themselves?)
(what happens when an anonymous user with data signs up or signs in? this is the cart combined problem)

an anonymous user navigates to the site
their browser gets a browser tag, which is set once, and never changes
the anonymous user stars a feed and sets a nickname, but does not sign up or sign in
it's a shared computer. another user navigates to the site and signs in
they use their account
they sign out
the browser goes back to showing the nicnmake of the anonymous user
a second user signs in
they user their account
they sign out
back to anon user
that anon user signs up
their stars and nickname carry into their new account

a signed in user visits a page that shows them
where they are currently signed in
where they have previously been signed in
with information from the browser's reported query string and geolocation, like city and country



user_address_table

user_browser_table

governor_table
the purpose of governor table is to 

short_code_table

attestation - this user has proven they control this address, different forms
governor - the system messaged this address hash this long ago, this many times
browser - this user tag is signed in with these browser tags
code - the we texted you this many numbers




first, just think about how the short code table works
even before you do the lettered and length variations--imagine all the codes are 6 digits long and random
how does it work that the user has to type it into the same





what prevents a user who has just gotten a 1234 code from trying 10,000 times for guaranteed entry?
turnstile will slow them down
the code will only last 20 minutes
should you also put a governor on trying answers for that code (on a hash of the codeTag in the page)?







== user identity 0.01

imagine this subset
no anonymous users
no email or sms or anything else
it's a user name, and a password
under the hood, there's a browser tag, and a user tag
users can sign up, sign in, sign out
users can delete their account, even--another user can sign up with that name
users can change their user name, their user tag does not change
two different users can share a computer

and a user has a page,
where there is a counter they can change
and a message they can change
(oh, their page also has a card:)

and if they are signed in, it shows where they are signed in
and where they used to be signed in, also
with just this, you can code the list that shows where the user is signed in,
and where they have been signed in

yeah, that's a good user identity 0.01
and also will show you
and then after that, add email
and by adding email successfully, you enable multifactor within the same schema
and email also includes one time codes
and forgot password, that flow

and after that, add sms
which is like another kind of email
and also has forgot password, validate, one time codes, code expiration, rate limiting
lots of advanced stuff

this is your current idea of how you get started with user identity
(1) password, demonstrating linking browserTag and userTag
(2) email, demonstrating one time code validation and forgot password and more
(3) sms, as an alternative additional method to email that you can add without much additional code or schema
















every code could be 4 digits, you now realize
a code only lives 20 minutes or 4 guesses, whichever happens first
it's tied to the browser hash, so a code stealer can't use it
import interactions are authenticated with a strong second factor, anyway

you're not sure how to do code B, code C, so on
because are those specific to the email?
or the browser?
but this might make things harder for the user

what if instead it's six digits and the first two are given
your code is 12-3456
and prepopulated in the box is 12-
or lowercase letters, and then they're before the box

ui7855
gx7588
and it's clear you can' ttype the letters because they're already there and the box is number only
yeah, maybe this is a good design

what if it's a single letter, omitting l and o and g

Your code is v9622 from cold3
and then the box shows the v within the box, but it's fancy css
yeah, this is better design for the user and for implementation

Code H [1234]
Your code H is 1234 from cold3. Don't share it with anyone--they could steal your whole account!





/*
[]rename to like:

[]queryDeleteRow - delete one row if it meets the specified criteria
[]queryDeleteRows - delete all rows that meet the specified criteria
[]querySetCell - change an existing cell to a new value
[x]queryAddRows - add several at once
[x]queryAddRow - add just one of them; these do all the checks first before leading to the same helper
[]queryCountRows - return the number of rows that meet specified criteria
[]queryGetRows - get all of them, sorted
[]queryGetPage - just the desired number, sorted by given title, have limit and offset
[]queryGetSingleRow - use when you know there's zero or one
[]queryGetRecentRow - use when there could be many


[]queryAddRow – Insert a single new row.
[]queryAddRows – Insert multiple new rows in bulk.
[]querySetCell – Update a single column in exactly one row.
[]querySetCells - update all the cells in a column, like setting their hide to 1
[]queryUpdateRow – Update multiple columns in exactly one row.
[]queryUpdateRows – Update one or more columns across all matching rows.
[]queryDeleteRow – Delete exactly one row matching specified criteria.
[]queryDeleteRows – Delete all rows matching specified criteria.
[]queryCountRows – Return the number of rows matching a condition.
[]queryGetRows – Retrieve all matching rows, possibly filtered, sorted.
[]queryGetNRows – Retrieve a limited set of matching rows, sorted.
[]queryGetSingleRow – Retrieve a unique row (or none) matching some condition.
[]queryGetRecentRow – Retrieve the most recent row (or a small set), usually by a time/tick column.
[]queryExists – Return a boolean indicating if any row matches a given condition. (Optional but common)

do not try to build out a complete set, there are two many permutations with a single table
and later when you're doing JOINs the permutations will go geometric
instead, all of these functions are table-agnostic
but made quite bespoke to an application use above in level3
if there's an obvious neighboring use, sure, include it
yeah, that's fine


you'll need a page, database test
and three buttons, Populate, Query, and Clear
yeah, this is a good idea, but don't spend more than a day on it


delete all the rows older than something
invalidate all the rows older than something by changing their hide to 2 or something


[]make it so snippet doesn't run adn doesn't render cloud; this is only local


*/




is this going slow because you don't have automated tests?
remember that you could code some up in example_table





here's how you figur eout the simple universal and correct way to link browser tags and user tags
make user sign up and sign in with password, only
have a message the user can see, themselves
let both anonymous users and signed-in useres see their message
do you need users to pick unique user names to do this? you think so, and that's fine




































/* level 3 query */

settingReadInt, settingRead, settingWrite,
browserSignedInSet, browserSignedInGet,

/* level 2 query */

snippetClear,
snippetPopulate,
snippetQuery,

queryFilterSortTop,
queryFilterSortAll,

querySetCell,
querySetCellOrAddRow,

queryGetCell,
queryGetCellOrAddRow,

queryGetRow,
queryGetRowOrAddRow,

queryAddRow,
queryAddRows,

queryCountRows,
queryCountAllRows,
queryDeleteAllRows,












plan out on paper how username and password-based sign up works

sign up
sign in
delete account

browser tag
user tag

user name

a user has a page and a message they can set
other users can see this page, but only the user can change it
you can change your password, but there's no forgot yet

a user's page has a card, which shows their name and when they signed up

a user's page can also have a list of where they're signed in

so from that, tables will probably be
user_password_table - says when p
user_access_table

there is a lot here, actually, even with only one way to sign in (name+password)
you'll figure out how browser tag and user tag are related
how sign out signs out everywhere
how pinia? holds the signed-in status, although you might check it every time in the database anyway






ok, real simple, on paper
imagine a user is already signed in
they have browserTag and userTag assigned
a worker gets a request from a page,
and the page tells the user that they are signed in, and what their userTag is
what is the database table that contains that information

row_tag  row_tick  hide  user_tag  browser_tag  signed_in

row tag, tick, hide are all just standard
user_tag of the user, browser_tag of the browser, signed_in 1 true means that the user is signed in there
browser_tag of the browser and signed_in 0 false means the user is signed out there, and everywhere else, too

so the worker, given a browser tag, wants to determine which user is signed in here
it filters on browser tag, looking at rows in descending order
there could be different users in that row set, of course

so now the worker is looking at a list, most recent first, of:

user_tag  signed_in
<meaningful>

no rows for this browser tag; nobody is signed in

user_tag  signed_in
alice     1 <--meaningful

only a single user has ever used this browser, and she's still signed in

user_tag  signed_in
alice     1 <--meaningful
alice     0
alice     1

here, just alice is using this browser, signed in, out, then in again
alice is signed in here

user_tag  signed_in
alice     0 <--meaningful
alice     1

nobody is signed in, alice has previously signed in, but signed out
this is good, that we still have data of what happened in the past here, because if alice signed up with method X, the sign in form can preference or hint at method X

user_tag  signed_in
bob       1 <--meaningful
alice     0
alice     1

after alice signed in and then out, bob signed in. bob is signed in here

user_tag  signed_in
alice     1 <--meaningful
bob       0
bob       1
alice     0
alice     1

alice signs in and out, bob signs in and out, then alice signs in


ok, so keeping with the simplification that a sign out signs out everywhere
looking at this, filtered for one browser, you will run into useres who look signed in here, but somewhere else, they signed out
you almost need a separate table of sign-outs:

sign_out_table
row_tick user_tag

so this is just the list of times when alice or bob last signed out
so here's how you use those?
you look at the sign-in table for this browser, to get the users who are currently signed in here
then you go to the signed out table to invalidate sign ins for alice that are older than her most recent sign out
wow, that's already a quite complex query

you just realized when you're doing the super authentication that only lasts 1 hour, or wahtever, and only exists on one browser, you can do that like this:

user_tag  signed_in
alice     2 <--meaningful
alice     1

assuming that the time now is within an hour of the 2 row

ok, back to one table
here's how the "who is signed in here?" worker figures that out
filter to just rows about this browser tag
from that, get all the users who have done something with this browser here

now you have a list of users
you go back to the table and pull all the rows about all of those users

user_tag  signed_in  browser_tag
alice     1          here
alice     1          elsewhere
bob       0          elsewhere
bob       1          here

users who are most recently signed in 0 you exclude--it doesn't matter whether they signed out here or elsewhere--they can sign in again

user_tag  signed_in  browser_tag
alice     1          here
alice     1          elsewhere

what if there's a separate table of user tag, and when they last signed out
so from the first table, you look at who's signed in here
that is, browser tag is here, signed in is >0, you get a list of users
you go down that list most recent to earlier, looking user by user at sign-outs in the other table. the first one you find who's signe din here and not signed out after that, is signed in here

ok, so that's pretty not simple, and you have hopeful doubt, rather than confidence, about its workign and ramifications

assuming private devices, it's also acceptably low number of round trips
but omg, you can't do this simple first thing with one query?!

here it is again, one table, a series of queries
pull all the rows about this browser tag and sign-ins
from that, you have a list of users who are or have ever signed in here

then do the second query--all sign out records of all of those users, everywhere
now you're piecing through that in the worker, i guess?
you go user by user, in order of signed in here
and then look at that user's most recent sign out, anywhere
the first signed in here user who doesn't have a more recent signed out, anywhere, is signed in here








what if the ledger design is a mistake?
what if instead, you should keep an actual unqueryable but free to blather ledger
and do things in the database by editing
like a normal DBA

(or, you actually use the row invalidation thing)
(or, you have both--a table that gets edited, to be fast and final, and alongside those, tables that are logs essentially, which you use to infer things and audit things--they can grow big and slow)

ok, what's that look like
there's a table that maps browser tag to user who is signed in here
there can only be one browser tag, so there's only one user who can be signed in
when a user signs out, we have to find all the browser tag rows where they are signed in, and sign them out of all of those
this is a bigger operation than just adding a new row to create a command and record to sign out





what if you hide rows as you go

othe ridea is to limit the number of places a user can sign in

but you're feeling better about this design now, though

user_browser_table - tells where users are signed in to what browsers
user_identification_table - tells how users prove they are who they say they are, with email, sms, metamask, two factor app codes, all that

also, let's design assuming two things
-supabase api always works
-two or more supabase commands do complete as a transaction (there isn't the same user writing a similar thing at the same time)
at this point, those assumptions are necessarily, essentially, to be able to move forward





browser_table


























