




































don't build wide at this level at thi stime
rather, sketch out what you'll need for the next list of things, like:
attestation - this user has proven they control this address, different forms
governor - the system messaged this address hash this long ago, this many times
browser - this user tag is signed in with these browser tags
code - the we texted you this many numbers
and then the other functions which you may need in the future, list those here in a brief comment, but don't code them

how does sign-in work, separate 

how dose code work, separate 


database tables:
1 hold simple, atomic facts (rather than the results of logic examining those facts)
	example: one row for sent code, another row for entered code
2 are a ledger that grows, rather than changes
	example: one row for added email, another later timestamped row for removed email
3 hold different kinds of data in a column (rather than having different tables for data)
	example: one table for every way to sign in, that grows as we add new sign-in methods (rather than JOINs between tables about email, sms, x, metamask, etc.)

first, sketch out on paper what the user does and what the system does through valid flows

a user, already signed in, returns to the site

an attacker enters a victims email address many times to get the victim to be sent codes they don't need

a user signes up with email
and then validates that email address

a user, already signed in, 

an anonymous user sets their nickname, and stars something

a signed-in user authenticates with another factor to perform a protected action, like changing sign in
these permissions only extend to their current device
an hour later, their permission level on that device returns to normal

a new user gets codes to validate their email address adn then sms number
the second code they get is code B
the third code they get is 6 digits, not 4

a user signs in on desktop
then on mobile
returns later and is still signed in
then signs out of everywhere on desktop
(what table links a user tag to their browser tags?)
(when does a user get a user tag? how does this work with anonymous users following a feed and renaming themselves?)
(what happens when an anonymous user with data signs up or signs in? this is the cart combined problem)

an anonymous user navigates to the site
their browser gets a browser tag, which is set once, and never changes
the anonymous user stars a feed and sets a nickname, but does not sign up or sign in
it's a shared computer. another user navigates to the site and signs in
they use their account
they sign out
the browser goes back to showing the nicnmake of the anonymous user
a second user signs in
they user their account
they sign out
back to anon user
that anon user signs up
their stars and nickname carry into their new account

a signed in user visits a page that shows them
where they are currently signed in
where they have previously been signed in
with information from the browser's reported query string and geolocation, like city and country



user_address_table

user_browser_table

governor_table
the purpose of governor table is to 

short_code_table

attestation - this user has proven they control this address, different forms
governor - the system messaged this address hash this long ago, this many times
browser - this user tag is signed in with these browser tags
code - the we texted you this many numbers




first, just think about how the short code table works
even before you do the lettered and length variations--imagine all the codes are 6 digits long and random
how does it work that the user has to type it into the same





what prevents a user who has just gotten a 1234 code from trying 10,000 times for guaranteed entry?
turnstile will slow them down
the code will only last 20 minutes
should you also put a governor on trying answers for that code (on a hash of the codeTag in the page)?







== user identity 0.01

imagine this subset
no anonymous users
no email or sms or anything else
it's a user name, and a password
under the hood, there's a browser tag, and a user tag
users can sign up, sign in, sign out
users can delete their account, even--another user can sign up with that name
users can change their user name, their user tag does not change
two different users can share a computer

and a user has a page,
where there is a counter they can change
and a message they can change
(oh, their page also has a card:)

and if they are signed in, it shows where they are signed in
and where they used to be signed in, also
with just this, you can code the list that shows where the user is signed in,
and where they have been signed in

yeah, that's a good user identity 0.01
and also will show you
and then after that, add email
and by adding email successfully, you enable multifactor within the same schema
and email also includes one time codes
and forgot password, that flow

and after that, add sms
which is like another kind of email
and also has forgot password, validate, one time codes, code expiration, rate limiting
lots of advanced stuff

this is your current idea of how you get started with user identity
(1) password, demonstrating linking browserTag and userTag
(2) email, demonstrating one time code validation and forgot password and more
(3) sms, as an alternative additional method to email that you can add without much additional code or schema
















every code could be 4 digits, you now realize
a code only lives 20 minutes or 4 guesses, whichever happens first
it's tied to the browser hash, so a code stealer can't use it
import interactions are authenticated with a strong second factor, anyway

you're not sure how to do code B, code C, so on
because are those specific to the email?
or the browser?
but this might make things harder for the user

what if instead it's six digits and the first two are given
your code is 12-3456
and prepopulated in the box is 12-
or lowercase letters, and then they're before the box

ui7855
gx7588
and it's clear you can' ttype the letters because they're already there and the box is number only
yeah, maybe this is a good design

what if it's a single letter, omitting l and o and g

Your code is v9622 from cold3
and then the box shows the v within the box, but it's fancy css
yeah, this is better design for the user and for implementation

Code H [1234]
Your code H is 1234 from cold3. Don't share it with anyone--they could steal your whole account!





/*
[]rename to like:

[]queryDeleteRow - delete one row if it meets the specified criteria
[]queryDeleteRows - delete all rows that meet the specified criteria
[]querySetCell - change an existing cell to a new value
[x]queryAddRows - add several at once
[x]queryAddRow - add just one of them; these do all the checks first before leading to the same helper
[]queryCountRows - return the number of rows that meet specified criteria
[]queryGetRows - get all of them, sorted
[]queryGetPage - just the desired number, sorted by given title, have limit and offset
[]queryGetSingleRow - use when you know there's zero or one
[]queryGetRecentRow - use when there could be many


[]queryAddRow – Insert a single new row.
[]queryAddRows – Insert multiple new rows in bulk.
[]querySetCell – Update a single column in exactly one row.
[]querySetCells - update all the cells in a column, like setting their hide to 1
[]queryUpdateRow – Update multiple columns in exactly one row.
[]queryUpdateRows – Update one or more columns across all matching rows.
[]queryDeleteRow – Delete exactly one row matching specified criteria.
[]queryDeleteRows – Delete all rows matching specified criteria.
[]queryCountRows – Return the number of rows matching a condition.
[]queryGetRows – Retrieve all matching rows, possibly filtered, sorted.
[]queryGetNRows – Retrieve a limited set of matching rows, sorted.
[]queryGetSingleRow – Retrieve a unique row (or none) matching some condition.
[]queryGetRecentRow – Retrieve the most recent row (or a small set), usually by a time/tick column.
[]queryExists – Return a boolean indicating if any row matches a given condition. (Optional but common)

do not try to build out a complete set, there are two many permutations with a single table
and later when you're doing JOINs the permutations will go geometric
instead, all of these functions are table-agnostic
but made quite bespoke to an application use above in level3
if there's an obvious neighboring use, sure, include it
yeah, that's fine


you'll need a page, database test
and three buttons, Populate, Query, and Clear
yeah, this is a good idea, but don't spend more than a day on it


delete all the rows older than something
invalidate all the rows older than something by changing their hide to 2 or something


[]make it so snippet doesn't run adn doesn't render cloud; this is only local


*/




is this going slow because you don't have automated tests?
remember that you could code some up in example_table




/* level 3 query */

settingReadInt, settingRead, settingWrite,

query_AccessTableInsert, query_AccessTableQuery,

/* query level 2 */

snippetClear,
snippetPopulate,
snippetQuery,

queryFilterSortAll,
queryFilterSortTop,

querySetCell,
querySetCellOrAddRow,

queryGetCell,
queryGetCellOrAddRow,

queryGetRow,
queryGetRowOrAddRow,

queryAddRow,
queryAddRows,

queryCountRows,
queryCountAllRows,
queryDeleteAllRows,































