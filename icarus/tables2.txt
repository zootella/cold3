



ok, you really broke it to clear out a bunch of old stuff
this imagines now you can quickly get it working again
with your new plan for browser_table and name_table (which does routes)

old flow that leads to functions to isolate, glance at, and delete:

site/stores/helloStore.js
v
site/server/api/hello1.js > browserToUser
site/server/api/hello2.js > authenticateSignGet

site/server/api/authenticate.js
v
authenticateSignGet > userToRoute
authenticateSignUp > routeToUser, routeAdd
authenticateSignIn > routeToUser
authenticateSignOut

new functions to write and use instead:

site/server/api/hello1.js > browserToUser
site/server/api/hello2.js > somethingNew({browserTag}) => {userTag, routeText}

( ~ new stuff on top of that calls down to:)
browserToUser
browserSignIn
browserSignOut

( ~ new stuff on top of that calls down to:)
getName
setName
removeName







2025feb19

## map



userToRoute,
routeToUser,
routeAdd,
routeRemove,
routeMove,

browserToUser,
browserSignIn,
browserSignOut,




/level1

checkNameNormal(nameNormal) makes sure nameNormal is a valid normalized route that doesn't change when we validate it
checkNamePage(namePage) makes sure namePage is a valid name for the page that doesn't change when we validate it
checkName(all three) makes sure that when we validate each of three they don't change, and also, that formal normalizes to normal!
(maybe put those into a single checkName which acts on what it's given--or maybe that's much harder to reason about)

validateName









## best thinking so far:

let's see if you can help with this:

```js
[I] what are the high level functions on top of this?

q1. im a browser with browser tag, what user if any is here? provisional, actual, or super
{<same browserTag>, userTag, 1+ level} = await browserToUser({browserTag})

c1. sign this user out everywhere right now!
await signOut({userTag, browserTag})

c2. the human here has entered information we should remember. they're not an actual user yet. make them a user tag to record that they were here, so they can pick up where they left off, maybe immediately, maybe in days
{<same browserTag>, userTag, level=1provisional} = await createUser({browserTag})

c3. the human here as proven they're this user with this user tag. sign them in here
c4. the human here has finished signing up, using this previously provisional user tag. sign them in here
await signInUser({browserTag, userTag})

[II] and then there's the middle part you're also figuring out

???

[III] which calls down to a table that you're pretty sure now looks like this

row_tag | row_tick | hide | browser_tag | user_tag | level
^the three starting ones
                            laptop        alice      0 signed out, but this row will immediately be hidden
                                                     1 provisional user signing up or customizing
                                                     2 normal actual signed in user
                                                     3 sudo, just for one hour, and just here
```


## stuff you'll clean up


(those sets of functions hanging around from a few weeks ago, list them here)









## notes about that

[]get rid of access_table, it's confusing you
blow it up. and its functions and endpoints and components, too
and you don't need the global access password anymore, either

you're pretty sure that duplicate visible cells for browser_tag and user_tag are totally expected
so that means you won't have any of those unique indices

1 so browserToUser does one query
but if it gets a user who's sudo, and that sudo is expired, it does two more queries
2 hide all the expired sudos, everywhere--all Kevin Uxbridge-style
3 repeat query 1
that's crazy but you think it'll work well
[]find the right index to make that really fast, probably just visible, chronological, level 3 rows, regardless of all the tags, yeah, that'll be really fast



here are some big pices that are about to come together:
-turnstile store
-route table
-user name validation
-nuxt dynamic routes and redirects
-check username form
and that's all separate from everything that's about to get settled in browser table



## ui you can make now

not sure how many different components this is
but it all leads down to browser_table and name_table as you've written them
also, at this point, all users have pages, this will of course not be the case
there may be a little bit of the provisional user peeking through here, as you may create the userTag before they actually choose and take a name

maybe try lots of different components, to see what that's like
harder at this point, but may let each grow to be larger and more complex?

```
~ UserInformationComponent
browser tag: "CnsWynLDKPgorrBcwEQLi"//exactly identifies browser, never changes
user tag: "07bnKpPvsq56NKKAIqtri"//exactly identifies user, never changes
page name: "2 Rainbows ðŸŒˆðŸŒˆ 4U"//user's current name as it shows up on pages and cards
formal name: "Rainbows-4U"//canonical working route, and 301 redirect destionation
normal name: "rainbows-4u"//normalized reserved route, unique, also a working route

~ UserInvitationComponent
[Sign Up] [Sign In]

~ UserIntakeComponent
Welcome new person! Sign up is easy; just choose a name for yourself.
[   ]name [Check Availability] <--sets all three for simplicity
[Sign Up]

~ UserAuthenticateComponent (which doesn't actually do any authentication yet!)
Welcome back! State your name to re-enter; we trust everyone at this point.
[   ]normal or formal name
[Sign In]

~ UserRenameComponent
You can edit your name as it appears on pages, cards, and links.
[   ]page name
[   ]formal name
[Check Availability] [Change Name]

~ UserExitComponent
[Sign Out] [Permanently Close Account] <--ooh!
```




you are not signed in


you are identified as:





see if you can do this in 25min with chat and tailwind
text boxes have a thick rounded border
you can change the color, from red to green
you can change the stroke, solid or dashed

buttons are solid color, with inverse video text
you can already change the color




	/*
	ttd february
	stop overloading cell2 -- the strength and permissions of a sign in will be handled elsewhere, most likely
	make browser_table really simple to think about (it's not yet)
	a browser visits for the first time; they get a browser tag
	the person enters the first bit of information; they get a user tag, this user tag isn't signed up yet, it's provisional
	the person provides more information, finishes signing up--pretty sure browser_table doesn't care about that
	the user signs out, everywhere--browser_table is all about this
	a user 
	*/



//ttd january - today's new level: self identified users with names that are routes
/*
bookmark january
ok, clicking through these four work
[]make another pass to be sure
[]see "Taken." get reported back up to the user
[]deal with an exception here telling the page 500--catch those in the page
[]understand where you check what up and down the stack
[]improve the form so you can show it to friends, like gray the buttons until they've entered text for user name that is an acceptable route; very minimal
-
and then what's next? maybe status message in a new table,
which the user, once signed in, can edit--new component for this
and then user page at a route that holds that message
and that's where you figure out how to get nuxt to do mixed root routes, which hopefully is common and easy
*/
//determine what user is signed into the given connected browser, and also get their route text (which we're using as user name in this early intermediate stage)












//removed this because now we have name_table, which has routes

//                  _         _        _     _      
//  _ __ ___  _   _| |_ ___  | |_ __ _| |__ | | ___ 
// | '__/ _ \| | | | __/ _ \ | __/ _` | '_ \| |/ _ \
// | | | (_) | |_| | ||  __/ | || (_| | |_) | |  __/
// |_|  \___/ \__,_|\__\___|  \__\__,_|_.__/|_|\___|
//                                                  

noop(`sql
-- go between a user's tag and route
CREATE TABLE route_table (
	row_tag     CHAR(21)  PRIMARY KEY  NOT NULL,
	row_tick    BIGINT                 NOT NULL,
	hide        BIGINT                 NOT NULL,

	user_tag    CHAR(21)               NOT NULL,
	route_text  TEXT                   NOT NULL   -- unique working route, normalized to lower case
);

-- quickly find the most recent visible row by user tag, and by route
CREATE INDEX route1 ON route_table (hide, user_tag,   row_tick DESC);
CREATE INDEX route2 ON route_table (hide, route_text, row_tick DESC);
`)


//ttd january []confirm that an exception here causes throws up all the way back to the page
//[]and hits datadog
//and then deal with exceptions in the page







yeah, you like this pattern

browser_table's functions:
browser_get
browser_signIn
browser_signOut

on name_table, you can see that the three functions you use to query that table are
name_get
name_set
name_delete








```
lots of states, permissions, roles, and life cycle-stages to think about:

most fundamental level:
- create (happens when user signing up provides first bit of information)
- identify
- delete (happens when user or staff bans)

slightly higher level on top of that:
- provisional (clicked follow) or signed up (has password)
- suspended (by staff)
- hidden (by user)

that kind of stuff, and then also, permissions:
- provisional
- normal
- staff

those categories and enumerations, and also, roles:
- creator
- just a fan

and more?! lots ot figure out here as we go from ameoba-stage to small multicelled organism
```









