



you are ready to code name-based sign up and sign in
which will use real tables and functions
even though it has the following simplifications
- all users have routes
- users identify themselves by their route
- "you are who you say you are" user validation for sign-in

from this first strand, though, you can code these features
[]a user has a status message
[]a user can change their status message, others can only view it
[]a user has a card that shows their status message
and you'll be able to code
[]a user hides and unhides themselves
[]a user closes their account



getting back to the cold forge,
find the existing tables, functions, and components which you have started building this in















./site/stores/helloStore.js
  v
./site/server/api/hello1.js > demonstrationSignHello
./site/server/api/hello2.js > demonstrationSignGet

./site/components/AuthenticateComponent.vue
./site/server/api/authenticate.js
  v
demonstrationSignGet
demonstrationSignUp
demonstrationSignIn
demonstrationSignOut

./icarus/level3.js

demonstrationSignHello > browser_get
demonstrationSignGet   > browser_get, name_get
demonstrationSignUp    >              name_get, name_set, browser_in
demonstrationSignIn    >              name_get,           browser_in
demonstrationSignOut   > demonstrationSignGet,                        browser_out

browser_get
browser_in
browser_out
TABLE browser_table (browser_tag, user_tag, level);

name_get
name_set
name_delete
TABLE name_table (user_tag, normal_text, formal_text, page_text);








use checkName on the page and server

on the page, the user is typing in the first box


on the page, the user is typing in the second box


on the server, 







export function checkName({formPage, formFormal, formNormal}) {
	let message = _checkName({formPage, formFormal, formNormal})
	if (message != 'Ok.') toss(message, {formPage, formFormal, formNormal})
}
function _checkName({formPage, formFormal, formNormal}) {
	let validPage, validFormal, validNormal
	if (given(formPage)) {//remember that blank strings, while not valid, are falsey!
		validPage = validateName(formPage, Limit.name)
		if (!validPage.formPageIsValid) return 'page form not valid'//page form can be valid, but not validate into the other two; they can be separate
		if (validPage.formPage != formPage) return 'page form round trip mismatch'
	}
	if (given(formFormal)) {
		validFormal = validateName(formFormal, Limit.name)
		if (!validFormal.isValid) return 'formal form not valid'
		if (validFormal.formFormal != formFormal) return 'formal form round trip mismatch'
	}
	if (given(formNormal)) {
		validNormal = validateName(formNormal, Limit.name)
		if (!validNormal.isValid) return 'normal form not valid'
		if (validNormal.formNormal != formNormal) return 'normal form round trip mismatch'
	}
	if (given(formFormal) && given(formNormal)) {//after checking all given forms individually, also make sure formal normalizes into normal
		if (validFormal.formNormal != formNormal) return 'round trip mismatch between normal and formal forms'
	}
	return 'Ok.'
}








































