# serverless.yml

service: net23
frameworkVersion: '4'
useDotenv: true
plugins:
  - serverless-offline #emulates Lambda and API Gateway for local development
  - serverless-domain-manager #use our domain for API Gateway and Lambda

provider:
  name: aws
  region: us-east-1
  runtime: nodejs22.x #updated 2025oct, Node 22 on Amazon Linux 2023 and good until 2027apr30, https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html
  architecture: arm64 #choose Amazon's custom Graviton2 chip for up to 30% quicker start, 25% faster execution, and 20% lower cost compared to default x86_64
  stage: prod #set production by default, as this script includes resources like buckets
  environment: #build these secret values from the local .env file into the server bundle
    ACCESS_K10_SECRET:         ${env:ACCESS_K10_SECRET}
    ACCESS_AMAZON_CERTIFICATE: ${env:ACCESS_AMAZON_CERTIFICATE} #promises not to change through automatic renewals; not sensitive or a secret but looks like one
  iam: #grant the identity role that runs the lambda functions additional permissions
    role:
      statements:
        - Effect: Allow
          Resource: '*' #for all the resources we might use, like sns topics or ses domains
          Action:
            - ses:* #give them full run of the messaging apis
            - sns:*
        - Effect: Allow #settings to allow pages to upload files to the bucket
          Resource: 'arn:aws:s3:::vhs-net23-cc'
          Action:
            - s3:ListBucket #needed for ListParts
        - Effect: Allow
          Resource: 'arn:aws:s3:::vhs-net23-cc/*'
          Action:
            - s3:PutObject
            - s3:GetObject

functions:
  message:
    handler: src/message.handler
    timeout: 25
    url:
      cors: false
    events: #BuildRemove
      - http: #BuildRemove
          path: /message #BuildRemove
          method: post #BuildRemove
  up2:
    handler: src/up2.handler
    timeout: 25
    url:
      cors: false
    events: #BuildRemove
      - http: #BuildRemove
          path: /up2 #BuildRemove
          method: post #BuildRemove
  up3:
    handler: src/up3.handler
    timeout: 25
    url:
      cors: false
    events: #BuildRemove
      - http: #BuildRemove
          path: /up3 #BuildRemove
          method: post #BuildRemove
  upload:
    handler: src/upload.handler
    timeout: 25
    url:
      cors: false #our code in upload.js handles CORS; see handleCorsPreflight(); but ttd january, maybe later add this back as it may be faster and cheaper than having the lambda code do it
    events: #BuildRemove: for local development with serverless-offline; build.js strips this for production deploy
      - http: #BuildRemove
          path: /upload #BuildRemove
          method: post #BuildRemove, lines that include "BuildRemove" build.js will remove

resources:
  Resources: #yes, it's correct to have resources twice and nested with different capitalization
    #before our first serverless deploy, staff performed manual steps to get the domain and ssl certificate, and put the ARN of the certificate in the .env file, referenced below

    WWWBucket: #create and configure a bucket
      Type: AWS::S3::Bucket
      Properties:
        BucketName: www-net23-cc #globally unique name in aws
        AccessControl: Private #private because a cloudfront distribution will serve files
    VHSBucket:
      Type: AWS::S3::Bucket
      Properties:
        BucketName: vhs-net23-cc
        AccessControl: Private #nobody can download from this bucket; media goes out through the cloudfront distribution
        CorsConfiguration: #but pages at the cloud and local domains for the Nuxt site can PUT into the bucket
          CorsRules:
            - AllowedOrigins:
                - ${env:ACCESS_ORIGIN_APEX_CLOUD}
                - ${env:ACCESS_ORIGIN_APEX_LOCAL}
              AllowedMethods:
                - PUT
              AllowedHeaders:
                - Content-Type
              ExposedHeaders:
                - ETag
    #ttd may2025, move the buckets from serverless.yml (configuration-as-code) to net23.txt (manual configuration) to keep their contents safe from the automatic teardown; your hopefull expectation is that since they have universally unique names, it'll be easy for the distributions, and perhaps even the access identities and bucket policies, to still reside here

    WWWBucketPolicy: #define a policy for a bucket to allow cloudfront access
      Type: AWS::S3::BucketPolicy
      Properties:
        Bucket: !Ref WWWBucket #the bucket this policy is about
        PolicyDocument: #a policy document with just one statement
          Statement: #allows the specified Principal, cloudfront OAI, to get objects from the bucket
            - Action: 's3:GetObject'
              Effect: Allow
              Resource: !Sub 'arn:aws:s3:::www-net23-cc/*' #reference to all objects in the bucket
              Principal:
                CanonicalUser: !GetAtt WWWAccessIdentity.S3CanonicalUserId
    VHSBucketPolicy:
      Type: AWS::S3::BucketPolicy
      Properties:
        Bucket: !Ref VHSBucket
        PolicyDocument:
          Statement:
            - Action: 's3:GetObject'
              Effect: Allow
              Resource: !Sub 'arn:aws:s3:::vhs-net23-cc/*'
              Principal:
                CanonicalUser: !GetAtt VHSAccessIdentity.S3CanonicalUserId

    WWWAccessIdentity: #create an OAI, a special user, so cloudfront can access the bucket
      Type: AWS::CloudFront::CloudFrontOriginAccessIdentity
      Properties:
        CloudFrontOriginAccessIdentityConfig:
          Comment: 'Made this OAI so CloudFront can read the www bucket to serve the static website' #comment saved in dashboard
    VHSAccessIdentity:
      Type: AWS::CloudFront::CloudFrontOriginAccessIdentity
      Properties:
        CloudFrontOriginAccessIdentityConfig:
          Comment: 'Made this OAI so CloudFront can read the vhs bucket to serve media files at the vhs subdomain'

    WWWDistribution: #create a cloudfront distribution which serves the static website files
      Type: AWS::CloudFront::Distribution
      Properties:
        DistributionConfig:
          Comment: 'Made this CloudFront distribution for www, the static site'
          Enabled: true
          Aliases:
            - www.net23.cc #for the static site, we don't redirect www to the bare domain, we serve it from both
            - net23.cc
          ViewerCertificate:
            AcmCertificateArn: ${env:ACCESS_AMAZON_CERTIFICATE} #get arm from .env file
            SslSupportMethod: sni-only
          DefaultRootObject: index.html
          Origins:
            - DomainName: !GetAtt WWWBucket.DomainName #internal aws domain name of the bucket
              Id: WWWOrigin
              S3OriginConfig:
                OriginAccessIdentity: !Sub 'origin-access-identity/cloudfront/${WWWAccessIdentity}'
          DefaultCacheBehavior:
            TargetOriginId: WWWOrigin
            DefaultTTL: 86400 #1 day in seconds, how long files stay in cache
            MaxTTL: 172800 #2 days, maximum time in cache
            MinTTL: 0 #zero to let cloudfront revalidate with the origin as needed
            ViewerProtocolPolicy: redirect-to-https # Redirect HTTP to HTTPS
            AllowedMethods:
              - GET
              - HEAD
            CachedMethods:
              - GET
              - HEAD
            ForwardedValues: #required parameter
              QueryString: false #do not forward a query string
              Cookies:
                Forward: none #by our Corporate Policy, Network 23 does not use cookies. the mere thought!
    VHSDistribution:
      Type: AWS::CloudFront::Distribution
      Properties:
        DistributionConfig:
          Comment: 'Made this CloudFront distribution for vhs, the media archive'
          Enabled: true
          Aliases:
            - vhs.net23.cc #no bare domain here, of course, vhs.net23.cc is the only domain for media files
          ViewerCertificate:
            AcmCertificateArn: ${env:ACCESS_AMAZON_CERTIFICATE}
            SslSupportMethod: sni-only
          DefaultRootObject: index.html
          Origins:
            - DomainName: !GetAtt VHSBucket.DomainName
              Id: VHSOrigin
              S3OriginConfig:
                OriginAccessIdentity: !Sub 'origin-access-identity/cloudfront/${VHSAccessIdentity}'
          DefaultCacheBehavior:
            TargetOriginId: VHSOrigin
            DefaultTTL: 86400 #1 day in seconds, how long files stay in cache
            MaxTTL: 172800 #2 days, maximum time in cache
            MinTTL: 0 #no time, allowing cloudfront to always get a fresh version from the bucket if necessary
            ViewerProtocolPolicy: redirect-to-https
            AllowedMethods:
              - GET
              - HEAD
            CachedMethods:
              - GET
              - HEAD
            ForwardedValues:
              QueryString: true #here, we do want the query string, because it contains the access code
              Cookies:
                Forward: none
            #you really tried to attach a Lambda@Edge function here, to no avail; instead, copy the CloudFront Function in vhs.cjs and paste it into a box in amazon's web dashboard

    Net23DomainRecords: #define a group of dns records in route 53
      Type: AWS::Route53::RecordSetGroup
      Properties:
        HostedZoneName: net23.cc. #we manually made this hosted zone before mentioning it here
        RecordSets:

          #bare domain goes to static site
          - Name: net23.cc. #ends with dot to indicate fully qualified
            Type: A #dns A records are for ipv4 addresses; AAAA below is for ipv6
            AliasTarget:
              DNSName: !GetAtt WWWDistribution.DomainName
              HostedZoneId: Z2FDTNDATAQYW2 #aws identifier for cloudfront
          - Name: net23.cc.
            Type: AAAA
            AliasTarget:
              DNSName: !GetAtt WWWDistribution.DomainName
              HostedZoneId: Z2FDTNDATAQYW2

          #www subdomain goes to static site
          - Name: www.net23.cc.
            Type: A
            AliasTarget:
              DNSName: !GetAtt WWWDistribution.DomainName
              HostedZoneId: Z2FDTNDATAQYW2
          - Name: www.net23.cc.
            Type: AAAA
            AliasTarget:
              DNSName: !GetAtt WWWDistribution.DomainName
              HostedZoneId: Z2FDTNDATAQYW2

          #vhs subdomain goes to media files
          - Name: vhs.net23.cc.
            Type: A
            AliasTarget:
              DNSName: !GetAtt VHSDistribution.DomainName
              HostedZoneId: Z2FDTNDATAQYW2
          - Name: vhs.net23.cc.
            Type: AAAA
            AliasTarget:
              DNSName: !GetAtt VHSDistribution.DomainName
              HostedZoneId: Z2FDTNDATAQYW2

          #you did manual dashboard steps to create the api.net23.cc record and connect it to "prod-net23", which this script created in API Gateway

  Outputs: #outputs, correctly here in the outer resources section, end up in the cloudformation template Outputs tab. things will probably work without creating any outputs here at all, but we're leaving it just in case we later find out it's helpful

    OutputWWWBucket:
      Description: 'Made this output identifier for the bucket for www static site files'
      Value: !Ref WWWBucket
    OutputVHSBucket:
      Description: 'Made this output identifier for the bucket for vhs media files'
      Value: !Ref VHSBucket

    OutputWWWDistribution:
      Description: 'Made this output identifier for the CloudFront distribution for www static site files'
      Value: !Ref WWWDistribution
    OutputVHSDistribution:
      Description: 'Made this output identifier for the CloudFront distribution for vhs media files'
      Value: !Ref VHSDistribution

    OutputWWWDistributionDomainName:
      Description: 'Made this output identifier for the domain name for www static site files'
      Value: !GetAtt WWWDistribution.DomainName
    OutputVHSDistributionDomainName:
      Description: 'Made this output identifier for the domain name for vhs media files'
      Value: !GetAtt VHSDistribution.DomainName

custom:
  serverless-offline:
    httpPort: 4000 #run locally on port 4000 instead of the default 3000 when we do $ npm run local, nuxt wants 3000
  customDomain: #settings for serverless-domain-manager to get lambdas up at api.net23.cc
    domainName: api.net23.cc
    basePath: ''
    stage: ${opt:stage, self:provider.stage}
    createRoute53Record: true
    endpointType: 'regional'
    securityPolicy: 'tls_1_2'
    certificateArn: ${env:ACCESS_AMAZON_CERTIFICATE}
