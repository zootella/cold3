notesfile


================================================================================
ðŸ”´ IMPLEMENTED â€” Early Task() prototype

Stream-of-consciousness notes with an early Task() code snippet. The implemented
version in level2.js:450-493 matches this design: tag, tick, sticker, finish()
method with automatic success bubbling. The note "try Task without Tape" reflects
what was ultimately builtâ€”Task survived, Tape was abandoned.
================================================================================

/*
export function Task(task) {
	checkText(task.name)//only name is required
	task.tag = Tag()//tag to identify this task
	task.tick = Now()//start time
	task.sticker = stickerParts()//where we're running to perform this task
	task.logged = false//flag for you to batch log at the end
	task.finish = function(more) {//mark this task done, adding more properites about how it concluded
		Object.assign(task, more)//be careful, as this overwrites anything already in task!
		if (task.error) task.success = false//if you pin an exception then success is false
		task.done = Now()//check .done to know it's done, and also when
		task.duration = task.done - task.tick//how long it took, nice that times are automatic
	}
	return task
}
*/



ok you're going to try Task without Tape
they're designed to be light and throwaway


================================================================================
ðŸ”´ IMPLEMENTED â€” High-level stack goals and architecture overview

Design goals document outlining the three-tier stack: [i] page, [ii] worker,
[iii] lambda. Goals included standardizing result/response/records, exception
handling at every level, and keeping Amazon details out of page responses.
All implemented: doorWorker/doorLambda handle errors uniformly, logAlert()
captures details server-side, and 500 responses return null to clients.
================================================================================

omg the stack is as tall as one of those three bread sandwiches

high level goals here:
[]standardize t1/t2/t3 and result/response/records on all levels
[]toss at every level of the stack, and understand how higher levels deal
[]experience non-exceptional failure at every level of the stack, and understand how higher levels deal
[]make sure that amazon details don't get sent to the page! be verbose in the worker, in datadog, not in the worker's response!

and here's where you clean up
[]single lambda warm that doesn't take provider or service, it's acting like a monolith
[]origin23 and fetch23, and how tests use them
[]getting the reference to $fetch where you need it

general patterns:

t1, t2, t3 - always have all three (even if you don't need t2), report duration = t3-t1

result
  .response
    .records

[i] the page

PostButton, codeStore, random other components
$fetch() to the worker below

[ii] the worker

./site/server/api/name.js
most just finish and return, but some
fetch23() to the lambda below

[iii] the lambda

./net23/src/message.js
calls amazon and twilio apis, which have their own exceptions and results


page success, page failure, page exception
worker success, worker failure, worker exception
lambda success, lambda failure, lambda exception


================================================================================
ðŸ”´ IMPLEMENTED â€” Getting things running / Spelunk button notes

Short implementation notes about getting the stack working and testing with a
debug button. This was working-phase scaffolding, now superseded by the working
implementation and proper test coverage.
================================================================================

first just get it working again




get things running again
make a [Spelunk] button that reaches down to lambda




	/*
	you get:
	result                  - our summary from the page's perspective of how the fetch went
	result.response         - the response body from the server
	result.response.records - records in List format with .tick and .tag for a pinia store
	*/


================================================================================
ðŸ”´ IMPLEMENTED â€” Door symmetry and logging location thoughts

Brainstorming about where to log errors (worker vs lambda) and whether door
should be symmetric. Concluded that exceptions should bubble up, workers log
via logAlert(), and lambdas return full details since callers are validated.
This is exactly how doorWorker/doorLambda work nowâ€”doorWorkerShut catches
errors and logs them, returning null to clients.
================================================================================

you built symmetry into door, but realize that thta design may not be optimal
for instance, it's important if the worker door handle below throws, that we datadog that, and not tell the page all the details
but the lambda can only be called by the page, so maybe it always returns full details
and the net23 does the job of logging things, including failures persephone experienced from apis
or, this is crazy, it's easiest to handle things right wehre they happen, and you've gotten datadog reliable from lambda no problem
and also, you haven't used supabase from lambda yet, so that's already all on in the worker


================================================================================
ðŸ”´ ABANDONED â€” Ledger/reports array idea

Brainstorming about passing an array through handlers where each operation adds
a "report" (turnstile check, amazon call, etc). This would flatten the nested
response structure. Noted "don't do that now, if ever!" and indeed it was never
implemented. The simpler Task pattern with success bubbling was sufficient.
================================================================================

you find yourself cooking up this idea where passed through the whole handler is an array where operations add reports, like turnstile is a report, a call to amazon is a report
which means that you don't have this deeply nested thing with sometimes multiple hardcoded responses inside
but don't do that now, if ever!



ugh what might the ledger look like
it woudl only be in the worker, the lambda reports back everything
a ledger item would have:
.t1 and .t2 and .duration
.sticker
.tag, identifier of the ledger item itself
.success
.provider, .service
.call
.request
.response

you could log an alert to datadog all at once at the end if there is any failure, or if something took too long
and log to datadog only from the worker, also

not response, but receipt


================================================================================
ðŸ”´ IMPLEMENTED â€” Charting course / exception testing checklist

Implementation checklist for testing exceptions and success states through the
stack. These were verification steps during development, now complete and
validated by the working system.
================================================================================

right now all you're trying to do is
[]chart the existing course
[]check api results for non success no throw
[]copy up success false
[]test out exceptions to see what to expect
[]keep times in there in a standard way even if you don't use them


================================================================================
ðŸ”´ IMPLEMENTED â€” Full stack code trace (code send flow)

Reference trace through the entire stack for sending a verification code:
CodeRequestComponent â†’ PostButton â†’ send.js â†’ codeSend() â†’ fetch23() â†’
message.js â†’ persephone.js. Function names evolved (fetch23 â†’ fetchLambda,
codeSend â†’ otpSend) but the architecture matches exactly. This was working
documentation during implementation.
================================================================================

~~~~ CodeRequestComponent.vue:

async function onClick() {
	let result = await refButton.value.post('/api/code/send', {

~~~~ PostButton.vue:

defineExpose({post: async (path, body) => {
...
		response = await $fetch(path, {method: 'POST', body})

~~~~ /server/api/send.js:

async function doorHandleBelow({door, body, action}) {
...
	response.sendResult = await codeSend({
		browserTag: body.browserTag,
		provider: provider,
		type: v.type,
		v: v,
	})
	response.records = await browserToCodes({browserTag: body.browserTag})
...
	return response
}

~~~~ level3.js, codeSend():

export async function codeSend({browserTag, provider, type, v}) {
...
	let result23 = await fetch23({$fetch, path: '/message', body})//ttd march2025, other notes about getting the nuxt
...
	return {success: true, result23}
}

~~~~ level2.js, fetch23():

export async function fetch23({$fetch, path, body}) {
...
	body.warm = true;  let resultWarm   = await $fetch(host+path, {method: 'POST', body})
	body.warm = false; let resultAction = await $fetch(host+path, {method: 'POST', body})
...
	return resultAction
}

~~~~ net23/src/message.js:

async function doorHandleBelow({door, body, action}) {
	let response = {}

	if (body.warm) {
		await warm(body.provider+body.service)
	} else {
		response.result = await sendMessage({
			provider: body.provider,
			service: body.service,
			address: body.address,
			subjectText: body.subjectText,
			messageText: body.messageText,
			messageHtml: body.messageHtml,
		})
	}

	return response
}

~~~~ net23/persephone/persephone.js

export async function sendMessage({provider, service, address, subjectText, messageText, messageHtml}) {
...
		if      (provider == 'Amazon.') { result = await message_AmazonEmail({fromName, fromEmail, toEmail, subjectText, messageText, messageHtml}) }
	logAudit('message', {provider, service, address, subjectText, messageText, messageHtml, result})
...
	return result
}


================================================================================
ðŸ”´ ABANDONED â€” Tape object design exploration

Extended brainstorming about a "Tape" object to hold a list of Task/Call objects.
The idea was to pass tape through handlers, with tape.add() collecting reports
and tape.ok() checking if all succeeded. Notes even explored auto-catching
exceptions. Ultimately abandonedâ€”the simpler Task-only approach with success
bubbling was sufficient without the extra abstraction layer.
================================================================================

what would it look like to pass around a really simple receipt

the door gives you a tape object
you add to it with tape.add({detail1, detail2, detail3}), there are required details
you merge it into the resposnse body


doorHandleBelow({door, body, action, tape})


ok and then how does it work with network 23
you pass net23 tape
it doesn't post it to the lambda
but does merge in the response

this is only a good idea if it means that you can keep the returns from these functions, and api handlers, really simple now, like true or false, even(?!) because tape has all the details
it means you don't have to buidl up this big deep tree as you go along

ok, see what adding this looks like




and now you realize, you give call a function and have it run it, and automatically catch an error and fail with it
weird, this is getting complicated like door
and also stepping on door's toes, somewhat
code it separate first, or not at all



Tape holds a list of
Call objects

let call = Call()//sets t1





success//looking at the response, not just for an error
	true to keep going; if false won't keep going


	vv optional to also pass in at the end

error, if there was one
guide//short human readable guidance for the user

	vv set internally:

t1
t2 == tick
duration
tag//identifies this call object
sticker//sticker where we did the call


body
request
response
result
records

logged


call.




ok, you coded up Task and Tape
and the're small and tight
keep them that way

next, try to use them to remove code around $fetch and api calls
leaving the return values just the minimal required for flow
essentially, see if Task and Tape help you remove a lot of details that most of the time aren't necessary


you can use Task both places
but probably only use Tape on the server


================================================================================
ðŸ”´ IMPLEMENTED â€” Task design summary

Concise Task requirements list. All implemented in level2.js:450-493:
tick/done/duration for timing, success detection, error capture. The current
Task() includes tag, sticker, and automatic success bubbling from nested
response/result objects.
================================================================================

Task
when did it start?
when did it finish?
how long did it take?
did it succeed?
did it throw?


================================================================================
ðŸ”´ ABANDONED â€” Detailed Task/Call field specifications

Specification for Task fields (provider, service, requestBody, sticker, etc.)
and how to use with Tape. This level of structure wasn't neededâ€”the implemented
Task is lighter, with just name, tag, tick, sticker, and finish(). Success
bubbling handles the rest without mandatory field lists.
================================================================================

/*
	mandatory to begin
provider
service

	optional to begin
body
parameters

	automatic to begin
sticker
tag
t1
logged

	mandatory to end
success

	optional to end
error
guide
response

	automatic to end
t2
duration
*/


================================================================================
ðŸ”´ IMPLEMENTED â€” Stack file listing

Quick reference of files in the stack flow. Still accurate for the architecture,
though some names changed (fetch23 â†’ fetchLambda, Task/Tape in level2 not level1).
================================================================================

CodeRequestComponent
PostButton
send.js
level3.js:codeSend
level2.js:fetch23
level1.js:Task and Tape


================================================================================
ðŸ”´ IMPLEMENTED â€” Light bracket idea (became Task)

Note about a minimal timing/success wrapper. This is exactly what Task() became:
title (name), sticker, tick, done, duration, success, error. The "light bracket"
intuition was correct.
================================================================================

waht if it's a really light bracket that just does

.title
.sticker
.tick
.done, .duration
.success
.error

and then try out putting that around lots of things in the stack




[]get Task to not include .error at all unless there is an error!


================================================================================
ðŸ”´ IMPLEMENTED â€” Monday afternoon issues (secrets + exceptions)

Two key insights: (1) net23 must not leak secrets even though only workers call
itâ€”implemented via envelope authentication and null error responses. (2) The
realization that checking if(task.success) feels wrong when exceptions would be
cleanerâ€”this led to the current philosophy where exceptions bubble up for code
errors while success/failure objects handle user-facing paths.
================================================================================

issues monday afternoon:

(1)
be careful that net23 doesn't leak secrets
if there's a valid access code, then it's ok to put lots of details in the response
but otherwise, it's a public api, so you can't allow any detail into the response, imagining that only a valid worker will be calling it!

(2)
you've written a simple Task that bubbles up success
but, using it, you find yourself checking if (task.success)
and then continuing
which seems wrong, that's what exceptions are for



you do like isolating higher risk blocks of code in try catch
let's say sesclient.send throws
what does that mean?
it means it's staff's fault, either an error in configuration, or usage
you do want to get that into datadog, but right now it's not going there


================================================================================
ðŸ”´ IMPLEMENTED â€” Exception bubbling realization

Key architectural insight: instead of Task and Tape complexity, just let
exceptions bubble up from persephone through lambda through worker. This is
exactly how the system works nowâ€”doorWorker/doorLambda catch exceptions at
the boundary, log them, and return appropriate responses. The "aha moment"
that simplified the design.
================================================================================

const tape = Tape()
if (tape.ok())




	/*
	now you suspect instead of writing Task and Tape, it's actually just about letting exceptions bubble all the way up from perspechone through here, which is much nicer!

	remember, we want to use exceptions for 'the platform is broken' situations
	here, this should always work--network 23 should be able to send a message
	so just confirm that if there's a problem with either the lambda
	or the amazon api, this leads to a thrown exception in the lambda
	which leads to a 500 from the fetch
	which leads to an exception that gets thrown up through here
	which goes all the way back to the page, and, i suppose, an exception there
	*/
	//does this throw if it's not successful? does it return a note in the return object?



	//ttd april2025, be able to tell if we think the code send worked ok or not


================================================================================
ðŸ”´ IMPLEMENTED â€” $fetch reference problem

Notes about Nuxt's $fetch being auto-imported in components/endpoints but hard
to reach from library files. The setFetch/getFetch pattern shown here was one
approach. Solved differently in the final implementationâ€”fetchWorker/fetchLambda
use $fetch directly (available in server context) or fall back to ofetch.
================================================================================

//ttd march2025, other notes about getting the nuxt environment reference $fetch




let _fetch//module scope variable to save Nuxt's $fetch, which Nuxt automatically imports into components and endpoints, but is hard to reach from library files!
export function setFetch(f) {
	if (!_fetch) _fetch = f
}
export function getFetch() {
	if (!_fetch) toss('no $fetch set')
	return _fetch
}


================================================================================
ðŸ”´ IMPLEMENTED/SIMPLIFIED â€” fetchNetwork23 with warmup logic

Old implementation of bridge to Network 23 with warmup calls, forceCloudLambda
flag, and Duration helper. The warmup pattern was abandonedâ€”reliability issues
were only on GET (now all POST), and the envelope-based authentication replaced
ACCESS_NETWORK_23_SECRET. Current fetchLambda() is much simpler: single POST
with sealed envelope. origin23() handles local vs cloud routing.
================================================================================

/*
ttd december2024, figure out how bridge works now that you've got cors done
write something small and simple which ping4 and test can use, too; right now they're doing this

to begin--don't do the warm thing, either--the errors you were seeing were only for GET, not POST
well, now you sort of want to do it
*/

/*
ttd march2025
you don't need forceCloudLambda anymore, you never used it
use {} for named arguments, of course
yeah do the warmup
*/

//  _          _     _              _                     _   ____  _____
// | |__  _ __(_) __| | __ _  ___  | |_ ___    _ __   ___| |_|___ \|___ /
// | '_ \| '__| |/ _` |/ _` |/ _ \ | __/ _ \  | '_ \ / _ \ __| __) | |_ \
// | |_) | |  | | (_| | (_| |  __/ | || (_) | | | | |  __/ |_ / __/ ___) |
// |_.__/|_|  |_|\__,_|\__, |\___|  \__\___/  |_| |_|\___|\__|_____|____/
//                     |___/

/*
forceCloudLambda false means local worker -> local lambda; cloud worker -> cloud lambda
forceCloudLambda true  means local worker -> cloud lambda; cloud worker -> cloud lambda
either way a cloud worker always calls to a cloud lambda, because callign down wouldn't work at all
*/
const _forceCloudLambda = false
const resourceLocalNetwork23 = 'http://localhost:4000/prod'//check your local Network 23 affliate
const resourceCloudNetwork23 = 'https://api.net23.cc'//or our global connectivity via satellite
function urlNetwork23(forceCloudLambda) {//where you can find Network 23; no trailing slash
	return (forceCloudLambda || isCloud({uncertain: 'Cloud.'})) ? resourceCloudNetwork23 : resourceLocalNetwork23
}
async function fetchNetwork23(nuxtDollarFetchFunction, providerDotService, path, body) {//pass in $fetch which nuxt has imported in site/server/api/caller.js but not here in icarus

	/*
	warm is the module that the lambda will use, like "AE" for amazon email
	if warm is set, then do a first warmup call, right here, before doing teh real call
	so callers of fetchNetwork23 get that warmup service for free, and don't have to think about it
	*/
	checkText(path); if (path[0] != '/') toss('data', {path, body})//call this with path like '/door'
	let access = await getAccess()
	let host = urlNetwork23(_forceCloudLambda)
	body.ACCESS_NETWORK_23_SECRET = access.get('ACCESS_NETWORK_23_SECRET')//don't forget your keycard

	let d = Duration()
	body.warm = true
	let resultWarm = await nuxtDollarFetchFunction(host+path, {method: 'POST', body})

	body.warm = false
	let resultAction = await nuxtDollarFetchFunction(host+path, {method: 'POST', body})
	d.finish()//but then log this or return this or something, right now you're just trying out your new Duration object
	return resultAction
	//ttd march2025, you like the warmup, but probably you don't need the "what we are warming up", just call warm to the lambda, and either that will warm up everything, or that can warm up everything, or that will not warm up everything but get things starting to get warm, which is all you need

	/*
	november
	[]retry if first one fails, but only once
	[]record the entire duration so you can see how long the whole two punch thing takes
	*/
}
/*
since adding sharp to lambdas, you've seen reliability problems!
like a 500 internal server error that is corrected by hitting refresh in the browser
and, the cold start is apparent now--a first hit in the morning takes seconds, then after that it's fast
so make this bridge first hit a wakup endpoint, and then do the real request
this simple stateless workaround won't slow things down much and is way easier than trying to clean up a failed request will preventing duplicate stateful real world action, like sending the user two text messages instead of one

ok, the flow is
1 do warm call
2 if failed, do warm call again
3 do real call

and log alerts when second warm call fails, meaning you don't try
or second warm call succeeds, meaning you fixed it but that was weird

but also--you've only seen these reliability problems on GET lambdas, never POST
you still like calling into a warm lambda, and the code isn't too hard, though
*/

//move to level0
function Duration(givenOpenTick) {//a small object to keep tick counts together for durations
	let _openTick, _shutTick, _duration
	function openTick() { return _openTick }//accessors
	function shutTick() { return _shutTick }
	function duration() { return _duration }

	_openTick = givenOpenTick ? givenOpenTick : Now()//use the given start time, or right now

	function finish() {//call a little later when whatever you're timing has finished
		_shutTick = Now()
		_duration = _shutTick - _openTick
	}
	return {openTick, shutTick, duration, finish}
}
//if you do this, have it keep an array with any number of durations, and then a .text() which summarizes gaps on one line


================================================================================
ðŸ”´ ABANDONED â€” Final Tape design with Task integration

Final attempt at Tape design showing how Task and Tape would work together.
The tape.finish(task, more) pattern with success bubbling. This was the cleanest
Tape design but still abandonedâ€”Task alone with success bubbling was sufficient.
The note "try to keep it like that" and "don't do the design where you take a
function and call it" shows the wisdom to avoid over-engineering.
================================================================================

//  _            _                      _   _
// | |_ __ _ ___| | __   __ _ _ __   __| | | |_ __ _ _ __   ___
// | __/ _` / __| |/ /  / _` | '_ \ / _` | | __/ _` | '_ \ / _ \
// | || (_| \__ \   <  | (_| | | | | (_| | | || (_| | |_) |  __/
//  \__\__,_|___/_|\_\  \__,_|_| |_|\__,_|  \__\__,_| .__/ \___|
//                                                  |_|

/*
let task = Task({
	name: 'doing something'//short and just for staff
	provider: 'Amazon.'//say the api we're contacting
	service: 'Email.'
	requestBody: {}//for a fetch, the body of our POST
	requestParameters: {}//for an api call, our parameters
	...//and whatever else you want, specific to what you're doing
})
tape.add(task, {
	success: true//check the details of what happened to confirm success
	error: e//catch an exception and keep here
	responseBody: {}//for a fetch, the response body we got back
	response: {}//for an api call, the api response
	guide: 'Request a new code to try again'//short message that is ok to send the user
	result
	...//and whatever else you want, specific to what you're doing
})
*/



/*
export function Tape() {
	let tasks = []//a tape holds a list of tasks
	let _success = true; function success() { return _success }//check tape.success() to keep going because no failure
	function finish(task, more) {//add a task to thish tape, providing finishing properties
		task.finish(more)
		if (!task.success) _success = false//bubble up a failure
		tasks.push(task)
	}
	return {tasks, finish, success}
}
*/
//^ttd april2025, ok, so that is really tight and simple, try to keep it like that
//for instance, don't do the design where you take a function and call it and catch an exception automatically


================================================================================
ðŸ”´ IMPLEMENTED â€” Pattern observations and implementation checklist

Notes about emerging patterns: exceptions in lambda can be rethrown in worker,
endpoints return function results directly, functions return tasks. All true
of the current implementation. The checklist at the bottom has most items
checkedâ€”the unchecked CodeEnterComponent item should be verified.
================================================================================

==== comments, bottom to top...

when using Task, check code for .success = true and .finish()

patterns developing:
- yes, you might catch an exception in the lambda, but then rethrow based on a failed task in the woker
- endpoints can return the result of a function call, rather than bundling things deep
- functions that get called by endpoints should return tasks




~~~~ send.js
the response body of the worker call is the object codeSend() returns
it's not a task, but does have a .success

~~~~ level3.js:codeSend()
saves the task from fetch23()--again, we're saving tasks rather than making and wrapping them, which is great
tosses to prevent keeping going, that pattern here again, also
doesn't return a task--rather returns an object with .success and minimal details, as this will be the body back to the page
this object, let's call it the response, even though it's never named, also has .codes for the pinia store

~~~~ level2.js:fetch23()
calls $fetch twice, saving, rather than making and wrapping, the tasks
checks the warm task for success, but then throws the task away
returns the actual task

~~~~ message.js
the response body of the lambda call is the task the functions return

~~~~ persephone.js
you've got tasks around warm and SESClient
warm lets an exception toss up, as this would indicate a code error
sesclient protects send with a try catch, as this is way more likely, if you've misconfigured amazon email, or they're misbehaving
this is also where you logAlert to datadog--tossing here wouldn't get the local context!
you return the task, which could contain secrets, but that's ok because the caller is a validated worker
note that if there was no keycard, door would have already thrown a detail-free 500



================================================================================
ðŸŸ¡ REVIEW â€” Final implementation checklist

Checklist with completion status. Most items checked [x], but one remains
unchecked: "CodeEnterComponent also works through the store to keep things
in sync". Need to verify if this was implemented or is still pending.
================================================================================

observe these three:
[x]happy path
[x]throw in block, no Destination
[x]throw in function
[x]throw in file



[~]just make a separate lambda endpoint which does nothing named warm

[x]refactor persephone unifying the four
[x]test the other three, happy path
[x]add success sanity checks to all four

[x]use Task in PostButton
[x]add the return codes records to codeStore


[x]CodeRequestComponent merges in return codes
[]CodeEnterComponent also works through the store to keep things in sync
