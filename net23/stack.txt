









omg the stack is as tall as one of those three bread sandwiches

high level goals here:
[]standardize t1/t2/t3 and result/response/records on all levels
[]toss at every level of the stack, and understand how higher levels deal
[]experience non-exceptional failure at every level of the stack, and understand how higher levels deal
[]make sure that amazon details don't get sent to the page! be verbose in the worker, in datadog, not in the worker's response!

and here's where you clean up
[]single lambda warm that doesn't take provider or service, it's acting like a monolith
[]host23 and fetch23, and how tests use them
[]getting the reference to $fetch where you need it

general patterns:

t1, t2, t3 - always have all three (even if you don't need t2), report duration = t3-t1

result
  .response
    .records

[i] the page

PostButton, codeStore, random other components
$fetch() to the worker below

[ii] the worker

./site/server/api/name.js
most just finish and return, but some
fetch23() to the lambda below

[iii] the lambda

./net23/src/message.js
calls amazon and twilio apis, which have their own exceptions and results


page success, page failure, page exception
worker success, worker failure, worker exception
lambda success, lambda failure, lambda exception






first just get it working again






get things running again
make a [Spelunk] button that reaches down to lambda






	/*
	you get:
	result                  - our summary from the page's perspective of how the fetch went
	result.response         - the response body from the server
	result.response.records - records in List format with .tick and .tag for a pinia store
	*/



you built symmetry into door, but realize that thta design may not be optimal
for instance, it's important if the worker door handle below throws, that we datadog that, and not tell the page all the details
but the lambda can only be called by the page, so maybe it always returns full details
and the net23 does the job of logging things, including failures persephone experienced from apis
or, this is crazy, it's easiest to handle things right wehre they happen, and you've gotten datadog reliable from lambda no problem
and also, you haven't used supabase from lambda yet, so that's already all on in the worker


you find yourself cooking up this idea where passed through the whole handler is an array where operations add reports, like turnstile is a report, a call to amazon is a report
which means that you don't have this deeply nested thing with sometimes multiple hardcoded responses inside
but don't do that now, if ever!



ugh what might the ledger look like
it woudl only be in the worker, the lambda reports back everything
a ledger item would have:
.t1 and .t2 and .duration
.sticker
.tag, identifier of the ledger item itself
.success
.provider, .service
.call
.request
.response

you could log an alert to datadog all at once at the end if there is any failure, or if something took too long
and log to datadog only from the worker, also

not response, but receipt







right now all you're trying to do is
[]chart the existing course
[]check api results for non success no throw
[]copy up success false
[]test out exceptions to see what to expect
[]keep times in there in a standard way even if you don't use them



~~~~ CodeRequestComponent.vue:

async function onClick() {
	let result = await refButton.value.post('/api/code/send', {

~~~~ PostButton.vue:

defineExpose({post: async (path, body) => {
...
		response = await $fetch(path, {method: 'POST', body})

~~~~ /server/api/send.js:

async function doorHandleBelow({door, body, action}) {
...
	response.sendResult = await codeSend({
		browserTag: body.browserTag,
		provider: provider,
		type: v.type,
		v: v,
	})
	response.records = await browserToCodes({browserTag: body.browserTag})
...
	return response
}

~~~~ level3.js, codeSend():

export async function codeSend({browserTag, provider, type, v}) {
...
	let result23 = await fetch23({$fetch, path: '/message', body})//ttd march, other notes about getting the nuxt 
...
	return {success: true, result23}
}

~~~~ level2.js, fetch23():

export async function fetch23({$fetch, path, body}) {
...
	body.warm = true;  let resultWarm   = await $fetch(host+path, {method: 'POST', body})
	body.warm = false; let resultAction = await $fetch(host+path, {method: 'POST', body})
...
	return resultAction
}

~~~~ net23/src/message.js:

async function doorHandleBelow({door, body, action}) {
	let response = {}

	if (body.warm) {
		await warm(body.provider+body.service)
	} else {
		response.result = await sendMessage({
			provider: body.provider,
			service: body.service,
			address: body.address,
			subjectText: body.subjectText,
			messageText: body.messageText,
			messageHtml: body.messageHtml,
		})
	}

	return response
}

~~~~ net23/persephone/persephone.js

export async function sendMessage({provider, service, address, subjectText, messageText, messageHtml}) {
...
		if      (provider == 'Amazon.') { result = await message_AmazonEmail({fromName, fromEmail, toEmail, subjectText, messageText, messageHtml}) }
	logAudit('message', {provider, service, address, subjectText, messageText, messageHtml, result})
...
	return result
}




what would it look like to pass around a really simple receipt

the door gives you a tape object
you add to it with tape.add({detail1, detail2, detail3}), there are required details
you merge it into the resposnse body


doorHandleBelow({door, body, action, tape})


ok and then how does it work with network 23
you pass net23 tape
it doesn't post it to the lambda
but does merge in the response

this is only a good idea if it means that you can keep the returns from these functions, and api handlers, really simple now, like true or false, even(?!) because tape has all the details
it means you don't have to buidl up this big deep tree as you go along

ok, see what adding this looks like




and now you realize, you give call a function and have it run it, and automatically catch an error and fail with it
weird, this is getting complicated like door
and also stepping on door's toes, somewhat
code it separate first, or not at all



Tape holds a list of
Call objects

let call = Call()//sets t1






success//looking at the response, not just for an error
	true to keep going; if false won't keep going


	vv optional to also pass in at the end

error, if there was one
guide//short human readable guidance for the user

	vv set internally:

t1
t2 == tick
duration
tag//identifies this call object
sticker//sticker where we did the call


body
request
response
result
records

logged


call.




ok, you coded up Task and Tape
and the're small and tight
keep them that way

next, try to use them to remove code around $fetch and api calls
leaving the return values just the minimal required for flow
essentially, see if Task and Tape help you remove a lot of details that most of the time aren't necessary


you can use Task both places
but probably only use Tape on the server








Task
when did it start?
when did it finish?
how long did it take?
did it succeed?
did it throw?

















/*
	mandatory to begin
provider
service

	optional to begin
body
parameters

	automatic to begin
sticker
tag
t1
logged

	mandatory to end
success

	optional to end
error
guide
response

	automatic to end
t2
duration
*/













CodeRequestComponent
PostButton
send.js
level3.js:codeSend
level2.js:fetch23
level1.js:Task and Tape






waht if it's a really light bracket that just does

.title
.sticker
.tick
.done, .duration
.success
.error

and then try out putting that around lots of things in the stack




[]get Task to not include .error at all unless there is an error!











