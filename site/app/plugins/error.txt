
notesfile



/*
good older note about over-registering (1) ttd february
if you did that, then every loose line of code in the client bundle would blow up the page, you reason

//ttd april2025, three more for the client that you're not going to start out with, as they could freak out unnecessarily
const router = useRouter()
router.onError((error) => {
	log('error handler 3', look({error}))
	nuxtApp.error({statusCode: 400, source: 'Router.', error, message: 'A routing error occurred.'})
})
window.addEventListener('error', (event) => {
	log('error handler 4', look({event}))
	nuxtApp.error({statusCode: 400, source: 'ScriptError.', event, message: 'A runtime error occurred.' })
})
window.addEventListener('unhandledrejection', (event) => {
	log('error handler 5', look({event}))
	nuxtApp.error({statusCode: 400, source: 'ScriptPromise.', event, message: 'An unhandled promise rejection occurred.' })
})
*/

/*
good older note about a third guard in a store (2) ttd february

ttd february2025 important
ok, but if a whole bunch of components show up on the page all at once
and they all call into getHits at the same time
coded this way, there will be a flurry of overlapping and identical fetch calls
so you need to isolate this as follows:
- if there's a fetch in flight, another one doesn't begin
- and you need to do the fancy promise thing where after the first or going fetch finishes, any number of await-ers all return at once

and you realized you need both protections
wrap this with sequentialShared - prevents multiple calls from overlapping on the page or cloud sides
and also leave gotten - prevents a second unnecessary call on the client side

also because action is different, you can't sequentialShared _fetchHit
you've got to add a layer between the calls above and _fetchHit below
*/








