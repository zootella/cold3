
notesfile



/*
good older note about over-registering (1) ttd february
if you did that, then every loose line of code in the client bundle would blow up the page, you reason

//ttd april2025, three more for the client that you're not going to start out with, as they could freak out unnecessarily
const router = useRouter()
router.onError((error) => {
	log('error handler 3', look({error}))
	nuxtApp.error({statusCode: 400, source: 'Router.', error, message: 'A routing error occurred.'})
})
window.addEventListener('error', (event) => {
	log('error handler 4', look({event}))
	nuxtApp.error({statusCode: 400, source: 'ScriptError.', event, message: 'A runtime error occurred.' })
})
window.addEventListener('unhandledrejection', (event) => {
	log('error handler 5', look({event}))
	nuxtApp.error({statusCode: 400, source: 'ScriptPromise.', event, message: 'An unhandled promise rejection occurred.' })
})
*/

/*
good older note about a third guard in a store (2) ttd february

ttd february2025 important
ok, but if a whole bunch of components show up on the page all at once
and they all call into getHits at the same time
coded this way, there will be a flurry of overlapping and identical fetch calls
so you need to isolate this as follows:
- if there's a fetch in flight, another one doesn't begin
- and you need to do the fancy promise thing where after the first or going fetch finishes, any number of await-ers all return at once

and you realized you need both protections
wrap this with sequentialShared - prevents multiple calls from overlapping on the page or cloud sides
and also leave gotten - prevents a second unnecessary call on the client side

also because action is different, you can't sequentialShared _fetchHit
you've got to add a layer between the calls above and _fetchHit below
*/

/*
good older note about how the same code mistake could throw in the client spa, or during a server render (3) ttd february

so if things are designed correctly and working well, the client throw will blow up the page, letting the user report
and the server throw will log the exception to datadog--but what does the page look like?

note that if there's an error in server rendering, things are so broken that we don't get to error.vue at all. the browser gets a static page titled Nuxt with a green glow at the bottom, and you tried to customize that, first with 500.html, then with a nuxt config error handler that used h3 to return a html string, but nothing worked; ok, added a notDefined to flexStore.getHits to try running into that in the client spa, and separately, the server render!
*/







