notesfile


for a first time visitor, hello will do one database query and the person will have the brochure page in ~150ms
for a signed-in and subscribed user, hello will do lots of queries, taking more time
delay_table will record real users' experiences
all users will go from a blank page to a fully rendered one
this will be a better experience than a page that, in several steps, expands into existance
several steps makes the page look slow; all-at-once hides the delay in the person's internet connection (Verizon's fault, not ours)
this design expects that the intent is that even for a complex user, this is still fast enough that we do not put a logo or spinner on the page before everything is loaded






get includes creator route--[]work on this new part next!







//ttd march2025, trying to do things in parallel with keepPromise, you were getting 4s delays on the page, "gave up waiting" errors in datadog, and 409 (Conflict) errors in supabase dashboard logs. so, you're going to do things one at a time from now on. but still, this is worrysome



taking more time, give a new tab more information from is browserTag and graphics hardware
like the user name
stage of teh user, like anonymous, current, suspended, closed
permission level of the user, like signed in normally, signed in for an hour of advanced permissions
creator or not








https://nuxt.com/docs/api/composables/use-async-data
is getting this right why it makes sense to use useAsyncData?

you added this to HitComopnent:

because, before, you were awaiting on the margin, and that seemed to work, but chat says it doesn't work
and when you did that, the hit component box appears before the hits now
and you're not sure if you can still see the sticker change from CloudPageServer to CloudPageClient

important:
[]confirm you can still get the page2 HitComponent "all at once" render experience
[]confirm you can still get it to change from Local/CloudPageServer to Local/CloudPageClient depending on if you navigate to, or click to, page2
[]undersatand, once and for all, or perhaps next, where to use $fetch versus useFetch and useAsyncData, now with pinia stores, and so on

answer: useFetch and useAsyncData solve the double-fetch problem for component-level data fetching WITHOUT a store. when you have pinia, the store itself prevents double-fetching:

const loaded = ref(false)
async function load() {
  if (loaded.value) return  // <-- this is your "fetch once" guard
  loaded.value = true
  let r = await fetchWorker('/api/load')
}

how it works:
1. server render: await mainStore.load() runs, sets loaded = true, fetches data
2. pinia bridge: nuxt serializes entire store state (including loaded = true) into HTML payload
3. client hydration: store hydrates with loaded = true already set
4. client calls load(): immediately returns because loaded.value is true - no second fetch

so $fetch + pinia loaded flag pattern = useFetch's double-fetch prevention, but with state living in your store where it belongs. adding useFetch on top of pinia would create two competing state systems.

useFetch is for one-off component data needs when you don't want a store. we have stores, so we use $fetch directly.




