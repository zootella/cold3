


ok, now you're here to rethink this, as follows:

[1] browser tag in secure private cookie
sent with every request
even the very first GET
can and must keep private from the page
no change to regulatory requirements
now there is an expiration: 395 days after their most recent visit
more secure than local storage because a browser extension cannot see the tag

[2] quick monoloth design
unify hello1 and hello2 into a single hello
for a first time visitor, hello will do one database query and the person will have the brochure page in ~150ms
for a signed-in and subscribed user, hello will do lots of queries, taking more time
delay_table will record real users' experiences
all users will go from a blank page to a fully hydrated one
this will be a better experience than a page that, in several steps, expands into existance
several steps makes the page look slow; all-at-once hides the delay in the person's internet connection (Verizon's fault, not ours)
this design expects that the intent is that even for a complex user, this is still fast enough that we do not put a logo or spinner on the page before everything is loaded





ok, looking at the sequence diagram now, you thought this was going to be about merging hello1 and hello2
but really it's going to be about doing everything on the very first GET, and getting rid of hello entirely!



1 -- browser GETs to server (this is hello0 the very first GET, before a POST to hello1)

right off the bat the server has:
- browser tag, from a cookie or just now set by middleware
- requested route, the creator page and card the user wants to see
- ip address, from connection
- user agent string, from headers

2 -- server responds with page and store

server writes to delay_table how long we took to prepare the page
server sends a pretty complete page to the browser, which is awesome, cookies really helped here

3 -- page POSTs to /api/hello

ok, at this point, what can the page say that the server doesn't already know?
browser graphics, but that's not important to keep as a feature, even, if it complicates this

page never knows browser tag, but browser puts it there again for server to match up

4 -- /api/hello1 responds with user and level

server reads ip address from connection
server reads user agent string from headers
server reads browser tag from body (changed to cookie)
server reads browser graphics from body (may get rid of entirely)
server reads time from its trusted clock

(now we can look things up)
browser tag -> user tag signed in here
user tag -> user name

5 -- page POSTs to /api/hello2
















./plugins/helloPlugin.client.js - runs as soon as the page hits a new tab; calls helloStore.hello1()
./stores/helloStore.js - .hello1() fetches to the first endpoint:
./server/api/hello1.js - very quickly tells if there's a user at this browser tag or not
./server/api/hello2.js - slower nonessential first run on tab tasks, like getting user stage and permissions information, logging the hit; this happens while components are loading and the user is clicking





maybe have layouts for:
brochure, no user is signed in yet
feed, user consuming content
panel, user changing their password
terms, legal docs like privacy and terms, static and minimal
machine, like ping, not meant for users to visit













1 -- browser GETs to server

get includes creator route--[]work on this new part next!

2 -- server responds with page and store

server can read ip address from connection
server can read user agent string from headers

3 -- page POSTs to /api/hello1

page includes browser tag in body
page includes browser graphics in body

4 -- /api/hello1 responds with user and level

server reads ip address from connection
server reads user agent string from headers
server reads browser tag from body
server reads browser graphics from body
server reads time from its trusted clock

(now we can look things up)
browser tag -> user tag signed in here
user tag -> user name

5 -- page POSTs to /api/hello2











it's fine to send a user tag to the page
never send a browser tag to the page!





thinking about the entire starting flow, you see why cookies may be better:
1 sent with every request, including the first GET, so saves ~150ms
2 page code can't read them, so a malicious browser extension can't get the browser tag
not sure if these two benefits are worth the drawbacks
- cookie regulation compliance
- browser cookie cleanup policies
- expiration dates and renewals

but looks like is possible, and would use
nuxt middleware
and code like this:
export default defineEventHandler((event) => {
    const cookieName = 'browser-uuid';
    const cookies = parseCookies(event);
    if (!cookies[cookieName]) {
        const uuid = uuidv4();
        setCookie(event, cookieName, uuid, {
            httpOnly: true,  // Prevent access from client-side JavaScript
            secure: true,    // Ensure it's only sent over HTTPS
            sameSite: 'Strict', // Prevent cross-site request forgery
            maxAge: 10 * 365 * 24 * 60 * 60 // Long lifespan (10 years)
        });
    }
});














