
//importing functions from icarus here may have made the cookie unreliable; but using automatic icarus imports from the server plugin seems to work ok ü§î ttd january

//                _                                             _
//   ___   __ _  (_)_ __ ___   __ _  __ _  ___    ___ __ _  ___| |__   ___
//  / _ \ / _` | | | '_ ` _ \ / _` |/ _` |/ _ \  / __/ _` |/ __| '_ \ / _ \
// | (_) | (_| | | | | | | | | (_| | (_| |  __/ | (_| (_| | (__| | | |  __/
//  \___/ \__, | |_|_| |_| |_|\__,_|\__, |\___|  \___\__,_|\___|_| |_|\___|
//        |___/                     |___/

/*
This middleware runs at the start of every request. It does two things:
1. Card images (/_og/* routes): CDN caching for the PNG social share cards rendered by nuxt-og-image's satori/WASM pipeline.
2. Everything else: reads or creates a browserTag cookie to identify the browser across sessions.
These two paths must not mix. If a Set-Cookie header appears on a card response, Cloudflare's CDN refuses to cache it.

üìê How it works: Cloudflare Workers run *in front of* the CDN, not behind it. A response generated by a Worker goes straight to the client ‚Äî the CDN never sees it, never caches it, regardless of Cache-Control headers. The only way to cache Worker-generated responses at the edge is the Cache API (caches.default), explicitly calling cache.match() and cache.put().

On a card request, this middleware checks the edge cache first. On hit, it returns the cached PNG (~40ms). On miss, it needs to invoke the full nuxt-og-image rendering pipeline ‚Äî but a plain fetch() to our own URL triggers Cloudflare's infrastructure-level loop detection (HTTP 522) before any application code runs. Instead, we use a SELF service binding (configured in wrangler.jsonc), which calls our own fetch handler on the same thread with no network overhead. Our custom x-card-render header on that inner request tells this middleware to step aside and let nuxt-og-image handle it. The rendered PNG comes back, we store it in the edge cache with waitUntil() (non-blocking), and return it to the client.

üåÄ Manual curl test: All this happens only in production; running locally every card request is a fresh render. To confirm production cards are working properly, use curl. Random each run to avoid any existing cache state.

```bash
OG_URL=$(curl -s "https://cold3.cc/card/test$RANDOM" | grep -o 'og:image" content="[^"]*' | head -1 | sed 's/og:image" content="//')
curl -s -D- -o /dev/null -w "\nTotal: %{time_total}s\n" "$OG_URL"
sleep 3
curl -s -D- -o /dev/null -w "\nTotal: %{time_total}s\n" "$OG_URL"
```

Confirm in results:
- **`x-card-source`** ‚Äî `FRESH` on first fetch (~650‚Äì1100ms, full satori render), `RECYCLED` on second (~40ms, edge cache)
- **`cf-cache-status`** ‚Äî Cloudflare's CDN confirmation. `HIT` on RECYCLED, absent on FRESH.
- **`age`** ‚Äî seconds since edge cached (present on RECYCLED)
- **`set-cookie`** ‚Äî must be absent. If present, the CDN won't cache and every request re-renders.
*/

const x_card_source = 'x-card-source'//outward-facing; set on every card response, RECYCLED or FRESH, so curl tests can verify the CDN caching layer is working
const x_card_render = 'x-card-render'//inward-facing; set to RENDER on the self.fetch() request to tell the subrequest to skip the cache and fall through to nuxt-og-image's renderer

export default defineEventHandler(async (workerEvent) => {//nuxt runs middleware like this at the start of every GET and POST request
	try {
		if (workerEvent.path.startsWith('/_og/')) {//the request is for a card image, like this is WhatsApp or ùïè on the line ‚òéÔ∏è note that setting a cookie on a response would cause cloudflare's CDN to not cache it!
			if (
				isCloud() &&//we're running deployed
				!getRequestHeader(workerEvent, x_card_render) &&//our own header means, this is us calling to render an image, don't try to get it from the CDN, return undefined here to have Nitro call nuxt-og-image to render a fresh card and return it to self.fetch() in the outer worker
				typeof caches != 'undefined' && caches.default &&//and two sanity checks of the cloudflare apis we'll use, we have the CDN,
				workerEvent.context.cloudflare?.env?.SELF &&//the service binding to ourselves we made in wrangler.jsonc is here,
				workerEvent.context.cloudflare?.context//and the worker's ctx parameter is defined, we'll call ctx.waitUntil()
			) {

				return await middlewareImage(workerEvent)//return the bytes of a card, either from a fresh render or cached in the CDN; returning non-undefined tells Nitro we've handled this request, no additional handlers run

			} else {
				return undefined//return undefined to have Nitro continue on to run the right handler for the route, which will be nuxt-og-image
			}
		} else {//browser requesting from worker

			middlewareCookie(workerEvent)//make sure the browser gets a renewed or filled-in browserTag to keep a user signed in
			return undefined//continue on to the handler for the route, like a page or api endpoint
		}
	} catch (e) { console.error(e); return undefined }//log an error to the cloudflare dashboard, but don't blow up the page, keep going into the handler for this route
})

async function middlewareImage(workerEvent) {

	let url = getRequestURL(workerEvent).toString()
	let cacheKey = new Request(url)//cloudflare's cache api keys on the full url, so each unique card has its own cache entry

	let hit = await caches.default.match(cacheKey)//do we already have this card cached?
	if (hit) {//yes ‚ôªÔ∏è return it from the CDN quickly

		for (let [k, v] of hit.headers) setHeader(workerEvent, k, v)
		setHeader(workerEvent, x_card_source, 'RECYCLED')//add a note for our manual curl testing that this card came from the CDN
		return new Uint8Array(await hit.arrayBuffer())//~40ms; serve the cached PNG directly, nothing downstream runs

	} else {//no üé® call ourselves to render the card, then store it in the CDN and return it

		const self = workerEvent.context.cloudflare.env.SELF//call back into ourselves via the SELF service binding we setup in wrangler.jsonc to render the card; a plain fetch() to our own url would 522 on cloudflare's loop detection
		let response = await self.fetch(new Request(url, {
			headers: {[x_card_render]: 'RENDER'}//command the inner invocation of ourselves to render a fresh card rather than checking the CDN, we're doing the CDN out here
		}))
		if (response.ok) {//the inner worker rendered the card

			let body = await response.arrayBuffer()//collect the PNG body
			let headers = {}
			for (let k of ['content-type', 'cache-control', 'etag', 'last-modified', 'vary']) {//pick headers that won't prevent the CDN from caching
				let v = response.headers.get(k)
				if (v) headers[k] = v
			}

			//store in the edge cache for next time; waitUntil keeps the isolate alive for the write after we've already responded
			let executionContext = workerEvent.context.cloudflare.context
			let store = caches.default.put(cacheKey, new Response(body.slice(0), { headers }))//slice(0) copies the buffer because Response consumes it
			executionContext.waitUntil(store)//waitUntil keeps this outer isolate alive to finish writing to the cache even after we respond; we can fire-and-forget, don't have to await above, the client gets their response now, the cache write finishes in the background

			//return the freshly rendered card to the client
			for (let [k, v] of Object.entries(headers)) setHeader(workerEvent, k, v)//copy the headers onto the outgoing response so the client gets content-type, cache-control, etag, etc.
			setHeader(workerEvent, x_card_source, 'FRESH')//note this card came from a fresh render for our manual curl testing
			return new Uint8Array(body)//~690ms on first render; every subsequent request for this card will be a ~40ms cache hit

		} else {//the inner invocation had some problem rendering the card, like satori threw

			//nothing to cache in the CDN, and no card image to return; forward the error response to the client as we got it
			setResponseStatus(workerEvent, response.status)//some non-2XX code
			setHeader(workerEvent, 'content-type',//without this Nitro sends a default content-type that doesn't match the error body
				response.headers.get('content-type') || 'text/plain')//or fall back to text/plain if the response has no content-type at all
			return response.body
		}
	}
}

//  _                                       _                                _    _      
// | |__  _ __ _____      _____  ___ _ __  | |_ __ _  __ _    ___ ___   ___ | | _(_) ___ 
// | '_ \| '__/ _ \ \ /\ / / __|/ _ \ '__| | __/ _` |/ _` |  / __/ _ \ / _ \| |/ / |/ _ \
// | |_) | | | (_) \ V  V /\__ \  __/ |    | || (_| | (_| | | (_| (_) | (_) |   <| |  __/
// |_.__/|_|  \___/ \_/\_/ |___/\___|_|     \__\__,_|\__, |  \___\___/ \___/|_|\_\_|\___|
//                                                   |___/                               

/*
a tag identifies a browser, through multiple different signed-in users, and even before someone has signed up
we could keep the browser tag in local storage, except then:
(1) the server doesn't have it from the very first GET; page code has to POST it to the server after loading
(2) malicious script on the page, most likely a browser extension, can see and leak the browser tag; this is a significant security advantage to cookies, as many users, even on chromebooks, have malicious extensions

moving the browser tag into a üç™ leaves behind the following advantages of local storage, though:
(3) there was no expiration date; local storage is meant to persist indefinitely
mitigated by:
	(3a) Safari and all browsers on iPhone can purge both cookies *and* localStorage after 7 days of user inactivity under Intelligent Tracking Prevention (Apple cloyingly pitches ITP as user protection; it also allows Apple to restrict web apps it cannot review, tax, and ban)
	(3b) we set our cookie to expire in 395 days (under Chrome‚Äôs 400‚Äëday cap) and refresh that TTL on every visit
(4) optics are farther from regulatory scrutiny; as a üñï-you to obtrusive, protectionless regulation, we could proudly state, "This site doesn‚Äôt even use cookies!"
mitigated by:
	(4a) privacy laws like GDPR and the ePrivacy Directive apply equally to any client‚Äëside identifier, not just cookies
	(4b) because our tag cookie is first‚Äëparty, strictly‚Äënecessary for core functionality, marked HttpOnly, Secure, and SameSite=Lax, compliance requires documenting its use in a privacy policy, and does not require explicit user consent
*/

function middlewareCookie(workerEvent) {

	//the steps below are designed to recover an existing browser tag, making a new one if something doesn't look right, and not throw; we don't want a malformed cookie to make the site unloadable
	let value, valueTag, browserTag
	value = getCookie(workerEvent, composeCookieName())//get the cookie where we may have previously tagged this browser
	valueTag = parseCookieValue(value)

	if (hasTag(valueTag)) {//if the above steps got a valid tag
		browserTag = valueTag//use the existing browser tag
		//log(`read ${browserTag} üç™`)
	} else {//otherwise, make and use a new browser tag
		browserTag = Tag()//create a tag to identify the connected browser
		//log(`made ${browserTag} üç™üî•`)
	}

	workerEvent.context.browserTag = browserTag//save the browser tag we just read or made in context, from H3, meant for us to add notes like this; door will find it here

	setCookie(workerEvent, composeCookieName(), composeCookieValue(browserTag), cookieOptions.browser)//set response headers for when we send the response, telling the browser to save this tag for next time
}
