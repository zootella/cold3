
//importing functions from icarus here may have made the cookie unreliable; but using automatic icarus imports from the server plugin seems to work ok ü§î ttd january

//                _                                             _
//   ___   __ _  (_)_ __ ___   __ _  __ _  ___    ___ __ _  ___| |__   ___
//  / _ \ / _` | | | '_ ` _ \ / _` |/ _` |/ _ \  / __/ _` |/ __| '_ \ / _ \
// | (_) | (_| | | | | | | | | (_| | (_| |  __/ | (_| (_| | (__| | | |  __/
//  \___/ \__, | |_|_| |_| |_|\__,_|\__, |\___|  \___\__,_|\___|_| |_|\___|
//        |___/                     |___/

/*
Cloudflare Workers run *in front of* the CDN, not behind it. A response generated by the worker goes straight to the client ‚Äî Cloudflare's CDN never sees it, never caches it, regardless of the Cache-Control header in our response.

To get CDN caching, the worker must explicitly use the Cloudflare Cache API (caches.default), which writes to the same edge cache the CDN uses. This middleware handles both cache reads and writes:

hit  ‚Üí serve from edge cache (~1-5ms), nothing downstream runs
miss ‚Üí invoke our own fetch handler via the SELF service binding (wrangler.jsonc), which re-enters
       the worker on the same thread without going through the CDN (avoiding the 522 loop detection
       that kills a plain fetch() self-request). The bypass header lets flow pass through on
       the subrequest so nuxt-og-image renders the png, and we store it in the edge cache for next time.
*/

export default defineEventHandler(async (workerEvent) => {//nuxt runs middleware like this at the start of every GET and POST request
	try {
		if (workerEvent.path.startsWith('/_og/')) {//the request is for a card image, like this is WhatsApp or ùïè on the line ‚òéÔ∏è note that setting a cookie on a response would cause cloudflare's CDN to not cache it!

			if (
				isCloud() &&//we're running deployed
				!getRequestHeader(workerEvent, 'x-og-render') &&//our own header means, this is us calling to render an image, don't try to get it from the CDN, return undefined here to have Nitro call nuxt-og-image to render a fresh card and return it to self.fetch() in the outer worker
				typeof caches != 'undefined' && caches.default &&//and two sanity checks of the cloudflare apis we'll use, we have the CDN,
				workerEvent.context.cloudflare?.env?.SELF &&//the service binding to ourselves we made in wrangler.jsonc is here,
				workerEvent.context.cloudflare?.context//and the worker's ctx parameter is defined, we'll call ctx.waitUntil()
			) {
				return await middlewareImage(workerEvent)//return the bytes of a card, either from a fresh render or cached in the CDN; returning non-undefined tells Nitro we've handled this request, no additional handlers run
			} else {
				return undefined//return undefined to have Nitro continue on to run the right handler for the route, which will be nuxt-og-image
			}

		} else {//browser requesting from worker

			middlewareCookie(workerEvent)//make sure the browser gets a renewed or filled-in browserTag to keep a user signed in
			return undefined//continue on to the handler for the route, like a page or api endpoint
		}
	} catch (e) { console.error(e); return undefined }//log an error to the cloudflare dashboard, but don't blow up the page, keep going into the handler for this route
})

async function middlewareImage(workerEvent) {

	let url = getRequestURL(workerEvent).toString()
	let cacheKey = new Request(url)

	//check edge cache
	let hit = await caches.default.match(cacheKey)
	if (hit) {
		for (let [k, v] of hit.headers) setHeader(workerEvent, k, v)
		setHeader(workerEvent, 'x-og-cache', 'HIT')
		return new Uint8Array(await hit.arrayBuffer())
	}

	//miss ‚Äî invoke our own fetch handler via the SELF service binding; this calls back into this worker on the same thread without going through the CDN, avoiding the 522 that a plain fetch() causes
	const self = workerEvent.context.cloudflare.env.SELF
	let response = await self.fetch(new Request(url, { headers: { 'x-og-render': '1' } }))

	if (!response.ok) {//render failed ‚Äî pass through the error without caching
		setResponseStatus(workerEvent, response.status)
		setHeader(workerEvent, 'content-type', response.headers.get('content-type') || 'text/plain')
		return response.body
	}

	let body = await response.arrayBuffer()
	let headers = {}
	for (let k of ['content-type', 'cache-control', 'etag', 'last-modified', 'vary']) {
		let v = response.headers.get(k)
		if (v) headers[k] = v
	}

	//store in edge cache; waitUntil lets this happen after we've already responded to the client
	let executionContext = workerEvent.context.cloudflare.context
	let store = caches.default.put(cacheKey, new Response(body.slice(0), { headers }))
	executionContext.waitUntil(store)//intentionally fire-and-forget; client gets the response now, cache write finishes in the background

	//return to client
	for (let [k, v] of Object.entries(headers)) setHeader(workerEvent, k, v)
	setHeader(workerEvent, 'x-og-cache', 'MISS')
	return new Uint8Array(body)
}

//  _                                       _                                _    _      
// | |__  _ __ _____      _____  ___ _ __  | |_ __ _  __ _    ___ ___   ___ | | _(_) ___ 
// | '_ \| '__/ _ \ \ /\ / / __|/ _ \ '__| | __/ _` |/ _` |  / __/ _ \ / _ \| |/ / |/ _ \
// | |_) | | | (_) \ V  V /\__ \  __/ |    | || (_| | (_| | | (_| (_) | (_) |   <| |  __/
// |_.__/|_|  \___/ \_/\_/ |___/\___|_|     \__\__,_|\__, |  \___\___/ \___/|_|\_\_|\___|
//                                                   |___/                               

/*
a tag identifies a browser, through multiple different signed-in users, and even before someone has signed up
we could keep the browser tag in local storage, except then:
(1) the server doesn't have it from the very first GET; page code has to POST it to the server after loading
(2) malicious script on the page, most likely a browser extension, can see and leak the browser tag; this is a significant security advantage to cookies, as many users, even on chromebooks, have malicious extensions

moving the browser tag into a üç™ leaves behind the following advantages of local storage, though:
(3) there was no expiration date; local storage is meant to persist indefinitely
mitigated by:
	(3a) Safari and all browsers on iPhone can purge both cookies *and* localStorage after 7 days of user inactivity under Intelligent Tracking Prevention (Apple cloyingly pitches ITP as user protection; it also allows Apple to restrict web apps it cannot review, tax, and ban)
	(3b) we set our cookie to expire in 395 days (under Chrome‚Äôs 400‚Äëday cap) and refresh that TTL on every visit
(4) optics are farther from regulatory scrutiny; as a üñï-you to obtrusive, protectionless regulation, we could proudly state, "This site doesn‚Äôt even use cookies!"
mitigated by:
	(4a) privacy laws like GDPR and the ePrivacy Directive apply equally to any client‚Äëside identifier, not just cookies
	(4b) because our tag cookie is first‚Äëparty, strictly‚Äënecessary for core functionality, marked HttpOnly, Secure, and SameSite=Lax, compliance requires documenting its use in a privacy policy, and does not require explicit user consent
*/

function middlewareCookie(workerEvent) {

	//the steps below are designed to recover an existing browser tag, making a new one if something doesn't look right, and not throw; we don't want a malformed cookie to make the site unloadable
	let value, valueTag, browserTag
	value = getCookie(workerEvent, composeCookieName())//get the cookie where we may have previously tagged this browser
	valueTag = parseCookieValue(value)

	if (hasTag(valueTag)) {//if the above steps got a valid tag
		browserTag = valueTag//use the existing browser tag
		//log(`read ${browserTag} üç™`)
	} else {//otherwise, make and use a new browser tag
		browserTag = Tag()//create a tag to identify the connected browser
		//log(`made ${browserTag} üç™üî•`)
	}

	workerEvent.context.browserTag = browserTag//save the browser tag we just read or made in context, from H3, meant for us to add notes like this; door will find it here

	setCookie(workerEvent, composeCookieName(), composeCookieValue(browserTag), cookieOptions.browser)//set response headers for when we send the response, telling the browser to save this tag for next time
}
