
//                _                                             _          
//   ___   __ _  (_)_ __ ___   __ _  __ _  ___    ___ __ _  ___| |__   ___ 
//  / _ \ / _` | | | '_ ` _ \ / _` |/ _` |/ _ \  / __/ _` |/ __| '_ \ / _ \
// | (_) | (_| | | | | | | | | (_| | (_| |  __/ | (_| (_| | (__| | | |  __/
//  \___/ \__, | |_|_| |_| |_|\__,_|\__, |\___|  \___\__,_|\___|_| |_|\___|
//        |___/                     |___/                                  

/*
Cloudflare Workers run *in front of* the CDN, not behind it. A response generated by the worker goes straight to the client — Cloudflare's CDN never sees it, never caches it, regardless of the Cache-Control header in our response.

To get CDN caching, the worker must explicitly use the Cloudflare Cache API (caches.default), which writes to the same edge cache the CDN uses. This middleware handler wraps /_og/ routes with that API:

hit  → serve from edge cache (~1-5ms), nothing downstream runs
miss → self-fetch with a bypass header, which re-enters the worker, triggers the og-image renderer, returns the png,
       and we store it in the edge cache for next time

The self-fetch is a second worker invocation on every cache miss. misses only happen once per card per edge datacenter, so after the first render, every subsequent request is a cache hit with zero worker execution.
*/
export default defineEventHandler(async (workerEvent) => {

	if (!workerEvent.path.startsWith('/_og/')) return//only og:image routes; everything else passes through untouched
	if (getRequestHeader(workerEvent, 'x-og-render')) return//this is our own subrequest coming back for rendering; let it through to nuxt-og-image
	if (!(typeof caches != 'undefined' && caches.default)) return//make sure the Cloudflare caches API is here; won't be running local

	try {

		const cache = caches.default
		let url = getRequestURL(workerEvent).toString()
		let cacheKey = new Request(url)

		//check edge cache
		let hit = await cache.match(cacheKey)
		if (hit) {
			for (let [k, v] of hit.headers) setHeader(workerEvent, k, v)
			setHeader(workerEvent, 'x-og-cache', 'HIT')
			return new Uint8Array(await hit.arrayBuffer())
		}

		//miss — self-fetch to render; must be fetch() not $fetch, because $fetch does an internal function call that stays inside this isolate; fetch() makes a real HTTP request that re-enters the worker as a new invocation
		let response = await fetch(url, {headers: {'x-og-render': '1'}})

		if (!response.ok) {//render failed — pass through the error without caching
			setResponseStatus(workerEvent, response.status)
			setHeader(workerEvent, 'content-type', response.headers.get('content-type') || 'text/plain')
			return response.body
		}

		let body = await response.arrayBuffer()
		let headers = {}
		for (let k of ['content-type', 'cache-control', 'etag', 'last-modified', 'vary']) {
			let v = response.headers.get(k)
			if (v) headers[k] = v
		}

		//store in edge cache; waitUntil lets this happen after we've already responded to the client
		let context = workerEvent.context.cloudflare?.context
		let store = cache.put(cacheKey, new Response(body.slice(0), {headers}))
		if (context) context.waitUntil(store)
		else await store

		//return to client
		for (let [k, v] of Object.entries(headers)) setHeader(workerEvent, k, v)
		setHeader(workerEvent, 'x-og-cache', 'MISS')
		return new Uint8Array(body)

	} catch {}//cache api failed — fall through silently and let the request proceed to nuxt-og-image's normal handler
})
