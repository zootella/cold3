
//                _                                             _
//   ___   __ _  (_)_ __ ___   __ _  __ _  ___    ___ __ _  ___| |__   ___
//  / _ \ / _` | | | '_ ` _ \ / _` |/ _` |/ _ \  / __/ _` |/ __| '_ \ / _ \
// | (_) | (_| | | | | | | | | (_| | (_| |  __/ | (_| (_| | (__| | | |  __/
//  \___/ \__, | |_|_| |_| |_|\__,_|\__, |\___|  \___\__,_|\___|_| |_|\___|
//        |___/                     |___/

/*
Cloudflare Workers run *in front of* the CDN, not behind it. A response generated by the worker goes straight to the client — Cloudflare's CDN never sees it, never caches it, regardless of the Cache-Control header in our response.

To get CDN caching, the worker must explicitly use the Cloudflare Cache API (caches.default), which writes to the same edge cache the CDN uses. This middleware handles cache hits:

hit  → serve from edge cache (~1-5ms), nothing downstream runs
miss → flag the event and let it fall through to nuxt-og-image's normal renderer;
       ogCachePlugin.js hooks beforeResponse to store the rendered image in the edge cache
*/
export default defineEventHandler(async (workerEvent) => {

	if (!workerEvent.path.startsWith('/_og/')) return//only og:image routes; everything else passes through untouched
	if (!(typeof caches != 'undefined' && caches.default)) return//make sure the Cloudflare Cache API is here; won't be running local

	try {

		let url = getRequestURL(workerEvent).toString()
		let cacheKey = new Request(url)

		//check edge cache
		let hit = await caches.default.match(cacheKey)
		if (hit) {
			for (let [k, v] of hit.headers) setHeader(workerEvent, k, v)
			setHeader(workerEvent, 'x-og-cache', 'HIT')
			return new Uint8Array(await hit.arrayBuffer())
		}

		//miss — flag for ogCachePlugin to store the response after nuxt-og-image renders it
		workerEvent.context._ogCacheKey = cacheKey

	} catch {}//cache api failed — fall through silently and let the request proceed to nuxt-og-image's normal handler
})
