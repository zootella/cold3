
//                _                                             _
//   ___   __ _  (_)_ __ ___   __ _  __ _  ___    ___ __ _  ___| |__   ___
//  / _ \ / _` | | | '_ ` _ \ / _` |/ _` |/ _ \  / __/ _` |/ __| '_ \ / _ \
// | (_) | (_| | | | | | | | | (_| | (_| |  __/ | (_| (_| | (__| | | |  __/
//  \___/ \__, | |_|_| |_| |_|\__,_|\__, |\___|  \___\__,_|\___|_| |_|\___|
//        |___/                     |___/

/*
Cloudflare Workers run *in front of* the CDN, not behind it. A response generated by the worker goes straight to the client — Cloudflare's CDN never sees it, never caches it, regardless of the Cache-Control header in our response.

To get CDN caching, the worker must explicitly use the Cloudflare Cache API (caches.default), which writes to the same edge cache the CDN uses. This middleware handles both cache reads and writes:

hit  → serve from edge cache (~1-5ms), nothing downstream runs
miss → invoke our own fetch handler via the SELF service binding (wrangler.jsonc), which re-enters
       the worker on the same thread without going through the CDN (avoiding the 522 loop detection
       that kills a plain fetch() self-request). The bypass header lets middleware10 pass through on
       the subrequest so nuxt-og-image renders the png, and we store it in the edge cache for next time.
*/
export default defineEventHandler(async (workerEvent) => {

	if (!workerEvent.path.startsWith('/_og/')) return//only og:image routes; everything else passes through untouched
	if (getRequestHeader(workerEvent, 'x-og-render')) return//this is our own subrequest coming back for rendering; let it through to nuxt-og-image
	if (!(typeof caches != 'undefined' && caches.default)) return//make sure the Cloudflare Cache API is here; won't be running local

	try {

		let url = getRequestURL(workerEvent).toString()
		let cacheKey = new Request(url)

		//check edge cache
		let hit = await caches.default.match(cacheKey)
		if (hit) {
			for (let [k, v] of hit.headers) setHeader(workerEvent, k, v)
			setHeader(workerEvent, 'x-og-cache', 'HIT')
			return new Uint8Array(await hit.arrayBuffer())
		}

		//miss — invoke our own fetch handler via the SELF service binding; this calls back into this worker on the same thread without going through the CDN, avoiding the 522 that a plain fetch() causes
		let self = workerEvent.context.cloudflare?.env?.SELF
		if (!self) return//SELF binding not configured; fall through to normal handler

		let response = await self.fetch(new Request(url, { headers: { 'x-og-render': '1' } }))

		if (!response.ok) {//render failed — pass through the error without caching
			setResponseStatus(workerEvent, response.status)
			setHeader(workerEvent, 'content-type', response.headers.get('content-type') || 'text/plain')
			return response.body
		}

		let body = await response.arrayBuffer()
		let headers = {}
		for (let k of ['content-type', 'cache-control', 'etag', 'last-modified', 'vary']) {
			let v = response.headers.get(k)
			if (v) headers[k] = v
		}

		//store in edge cache; waitUntil lets this happen after we've already responded to the client
		let context = workerEvent.context.cloudflare?.context
		let store = caches.default.put(cacheKey, new Response(body.slice(0), { headers }))
		if (context) context.waitUntil(store)
		else await store

		//return to client
		for (let [k, v] of Object.entries(headers)) setHeader(workerEvent, k, v)
		setHeader(workerEvent, 'x-og-cache', 'MISS')
		return new Uint8Array(body)

	} catch {}//cache api failed — fall through silently and let the request proceed to nuxt-og-image's normal handler
})
